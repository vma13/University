#ifndef __TXX__
#define __TXX__
#ifndef __tplusplus

#define tfun 
#define tval
#define tptr *
#define tout &
#define tdrop(v)
#define twait(v,s) (s)
#define tct(ts)

#define TFUNDEF(type,fun,pars,stas,args,argi,outs,outi,msize)  type fun pars 
#define TFUNIMPL(type,fun,pars,stas,args,argi,outs,outi,msize) type fun pars

static long ts_sysconf(int name)
{
  if (name== _SC_CL_SIZE) return 1;
  if (name==  _SC_CL_MPI_RANK) return 0; // :-)
  return sysconf(name);
}
#define sysconf ts_sysconf

#else //  __tplusplus

#ifdef DBG
#define GLUE2(x,y) x,y /* needed to pass template with ID as signle macro argument */
#endif//DBG

// Under TG++, TVar methods are not accessible to the user
// Re-implemented as inline function, see ./trt.hh

#ifndef __TGPLUSPLUS__
#define tdrop(x) do {(x).drop();} while (0)
#endif

#define tct(ts) _tc_##ts

#ifdef   AUTO_C_CALL
#define MAYBE_C_CALL(type,fun,purepars) \
  ts::conf.autoCcall = true; /* do it here? */ \
  ts::Task *_curr = ts::Task::getCurrent(); \
  if (_curr && (*_curr)().do_C_call) { \
    return fun##Cversion purepars; \
  } 
#else// !AUTO_C_CALL
#define MAYBE_C_CALL(type,fun,purepars)
#endif// AUTO_C_CALL

// Add to factory (New) tct() from definition
#define TFUNDEF(type,fun,pars,purepars,stas,args,argi,outs,outi) \
extern ts::TFunCtxt fun##TFunCtxt; \
struct fun##TArgDef { args ts::TFunCtxt* _fid; }; \
struct fun##TFunDef: public ts::TFun<type, fun##TFunCtxt>, fun##TArgDef { \
  outs \
  virtual ts::TFrz<type> body() = 0; \
  static fun##TFunDef* New(); \
}; \
type fun##Cversion pars; \
static inline ts::TFrz<type> fun pars { \
  ts::TSLocker _l; \
  MAYBE_C_CALL(type,fun,purepars); \
  fun##TFunDef *_tf = fun##TFunDef::New(); \
  argi \
  _tf->stopAndContParent(); \
  _tf = (fun##TFunDef*)fun##TFunDef::tryToReuseMemo(_tf,(fun##TArgDef*)_tf,sizeof(fun##TArgDef)); \
  outi \
  return _tf->retfrz; \
} 

// Add tct here
#define TFUNIMPL(type,fun,pars,purepars,stas,args,argi,outs,outi) \
ts::TFunCtxt fun##TFunCtxt(#fun);\
struct fun##TArgImpl { args ts::TFunCtxt* _fid; }; \
struct fun##TFunImpl: public ts::TFun<type,fun##TFunCtxt>, fun##TArgImpl { \
  outs stas \
  virtual ts::TFrz<type> body(); \
  virtual ts::SData* clone(); \
}; \
ts::SData* fun##TFunImpl::clone() { \
  size_t extra = ts::Task::get_extra(); \
  ts::SData* p = \
    (ts::SData*)(new(extra) fun##TFunImpl(*this)); \
  if (extra > 0) \
    memcpy((char*)p + sizeof(fun##TFunImpl),(char*)this + sizeof(fun##TFunImpl),extra); \
  return p; \
} \
fun##TFunDef* fun##TFunDef::New() { \
  size_t extra = ts::Task::get_extra(); \
  fun##TFunDef* p = (fun##TFunDef*)(new(extra) fun##TFunImpl); \
  p->_fid = &fun##TFunCtxt; \
  ts::Task::after_ctor(p); \
  return p; \
} \
ts::TFrz<type> fun##TFunImpl::body()


#endif //__tplusplus
#endif //__TXX__
# 1 "t.c"
# 1 "<built-in>"
# 1 "<command line>"



# 1 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 1
# 13 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 329 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 313 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 314 "/usr/include/sys/cdefs.h" 2 3 4
# 330 "/usr/include/features.h" 2 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 353 "/usr/include/features.h" 2 3 4
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 26 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 213 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 3 4
typedef unsigned int size_t;
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 134 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 135 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 27 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/time.h" 1 3 4
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 65 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 104 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 33 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 76 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 25 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 31 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 40 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 44 "/usr/include/time.h" 2 3 4
# 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 132 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();





# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 217 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();

extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 389 "/usr/include/time.h" 3 4
extern int getdate_err;
# 398 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 412 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 26 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 400 "/usr/include/signal.h" 3 4
}
# 29 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 29 "/usr/include/bits/setjmp.h" 3 4
typedef int __jmp_buf[6];
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 32 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED_NP,
  PTHREAD_MUTEX_ROBUST_NP
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 114 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 146 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 181 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 219 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 465 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 477 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 511 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 711 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 845 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 957 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1068 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1102 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1116 "/usr/include/pthread.h" 3 4
}
# 14 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 173 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 174 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 178 "/usr/include/unistd.h" 2 3 4
# 191 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 198 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 238 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 258 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 301 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 312 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 343 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 371 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;
# 393 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 405 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 429 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 471 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 555 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 591 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 617 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 634 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 837 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 171 "/usr/include/getopt.h" 3 4
}
# 838 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 923 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();




extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 960 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 970 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 980 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 990 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1011 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1034 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1044 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1065 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
# 1103 "/usr/include/unistd.h" 3 4
}
# 15 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;






extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 429 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 439 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;







extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 613 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));






extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 698 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 709 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 719 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;








extern int system (__const char *__command) ;







extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 756 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 821 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 909 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 977 "/usr/include/stdlib.h" 3 4
}
# 17 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 121 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 426 "/usr/include/string.h" 3 4
}
# 18 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4


typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 354 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 167 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 177 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 200 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 268 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 316 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 325 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 361 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern wint_t __wunderflow (_IO_FILE *);
extern wint_t __wuflow (_IO_FILE *);
extern wint_t __woverflow (_IO_FILE *, wint_t);
# 451 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 481 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 543 "/usr/include/libio.h" 3 4
}
# 73 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void);
# 181 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void);



extern char *tmpnam (char *__s) throw ();





extern char *tmpnam_r (char *__s) throw ();
# 203 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 228 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 238 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
# 269 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes);
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream);




extern FILE *fdopen (int __fd, __const char *__modes) throw ();





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw ();


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) throw ();




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw ();






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));







extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 460 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 471 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 504 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 550 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 566 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 627 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 638 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 674 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 693 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 716 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 755 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 774 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 844 "/usr/include/stdio.h" 3 4
}
# 19 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stdarg.h" 1 3 4
# 20 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 75 "/usr/include/signal.h" 3 4
typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 104 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, __const char *__s);
# 153 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 162 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 181 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 196 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;
# 212 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 213 "/usr/include/signal.h" 2 3 4



extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 247 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     throw ();
# 304 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 328 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) throw ();



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/asm/sigcontext.h" 1 3 4
# 19 "/usr/include/asm/sigcontext.h" 3 4
struct _fpreg {
 unsigned short significand[4];
 unsigned short exponent;
};

struct _fpxreg {
 unsigned short significand[4];
 unsigned short exponent;
 unsigned short padding[3];
};

struct _xmmreg {
 unsigned long element[4];
};

struct _fpstate {

 unsigned long cw;
 unsigned long sw;
 unsigned long tag;
 unsigned long ipoff;
 unsigned long cssel;
 unsigned long dataoff;
 unsigned long datasel;
 struct _fpreg _st[8];
 unsigned short status;
 unsigned short magic;


 unsigned long _fxsr_env[6];
 unsigned long mxcsr;
 unsigned long reserved;
 struct _fpxreg _fxsr_st[8];
 struct _xmmreg _xmm[8];
 unsigned long padding[56];
};



struct sigcontext {
 unsigned short gs, __gsh;
 unsigned short fs, __fsh;
 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned long edi;
 unsigned long esi;
 unsigned long ebp;
 unsigned long esp;
 unsigned long ebx;
 unsigned long edx;
 unsigned long ecx;
 unsigned long eax;
 unsigned long trapno;
 unsigned long err;
 unsigned long eip;
 unsigned short cs, __csh;
 unsigned long eflags;
 unsigned long esp_at_signal;
 unsigned short ss, __ssh;
 struct _fpstate * fpstate;
 unsigned long oldmask;
 unsigned long cr2;
};
# 29 "/usr/include/bits/sigcontext.h" 2 3 4
# 334 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();
# 346 "/usr/include/signal.h" 3 4
extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 349 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 27 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/sys/ucontext.h" 2 3 4



typedef int greg_t;





typedef greg_t gregset_t[19];



enum
{
  REG_GS = 0,

  REG_FS,

  REG_ES,

  REG_DS,

  REG_EDI,

  REG_ESI,

  REG_EBP,

  REG_ESP,

  REG_EBX,

  REG_EDX,

  REG_ECX,

  REG_EAX,

  REG_TRAPNO,

  REG_ERR,

  REG_EIP,

  REG_CS,

  REG_EFL,

  REG_UESP,

  REG_SS

};



struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 352 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();
# 388 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
# 21 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/malloc.h" 1 3 4
# 24 "/usr/include/malloc.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 151 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 25 "/usr/include/malloc.h" 2 3 4
# 46 "/usr/include/malloc.h" 3 4
extern "C" {


extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;


extern void *calloc (size_t __nmemb, size_t __size) throw ()
       __attribute__ ((__malloc__)) ;



extern void *realloc (void *__ptr, size_t __size) throw ()
       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));


extern void free (void *__ptr) throw ();


extern void cfree (void *__ptr) throw ();


extern void *memalign (size_t __alignment, size_t __size) throw ()
       __attribute__ ((__malloc__)) ;


extern void *valloc (size_t __size) throw ()
       __attribute__ ((__malloc__)) ;



extern void * pvalloc (size_t __size) throw ()
       __attribute__ ((__malloc__)) ;



extern void *(*__morecore) (ptrdiff_t __size);


extern void *__default_morecore (ptrdiff_t __size) throw ()
       __attribute__ ((__malloc__));



struct mallinfo {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};


extern struct mallinfo mallinfo (void) throw ();
# 130 "/usr/include/malloc.h" 3 4
extern int mallopt (int __param, int __val) throw ();



extern int malloc_trim (size_t __pad) throw ();



extern size_t malloc_usable_size (void *__ptr) throw ();


extern void malloc_stats (void) throw ();


extern void *malloc_get_state (void) throw ();



extern int malloc_set_state (void *__ptr) throw ();




extern void (*__malloc_initialize_hook) (void);

extern void (*__free_hook) (void *__ptr, __const void *);

extern void *(*__malloc_hook) (size_t __size, __const void *);

extern void *(*__realloc_hook) (void *__ptr, size_t __size, __const void *);

extern void *(*__memalign_hook) (size_t __alignment, size_t __size, __const void *);


extern void (*__after_morecore_hook) (void);


extern void __malloc_check_init (void) throw ();


}
# 22 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/sys/time.h" 1 3 4
# 29 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/sys/time.h" 2 3 4
# 39 "/usr/include/sys/time.h" 3 4
extern "C" {
# 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     throw () __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) throw ();
# 191 "/usr/include/sys/time.h" 3 4
}
# 23 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/sys/resource.h" 1 3 4
# 25 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/bits/resource.h" 1 3 4
# 33 "/usr/include/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,


  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 127 "/usr/include/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1,




  RUSAGE_THREAD = 1




};


# 1 "/usr/include/bits/time.h" 1 3 4
# 175 "/usr/include/bits/resource.h" 2 3 4


struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    long int ru_maxrss;


    long int ru_ixrss;

    long int ru_idrss;

    long int ru_isrss;


    long int ru_minflt;

    long int ru_majflt;

    long int ru_nswap;


    long int ru_inblock;

    long int ru_oublock;

    long int ru_msgsnd;

    long int ru_msgrcv;

    long int ru_nsignals;



    long int ru_nvcsw;


    long int ru_nivcsw;
  };







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};
# 26 "/usr/include/sys/resource.h" 2 3 4






extern "C" {
# 43 "/usr/include/sys/resource.h" 3 4
typedef int __rlimit_resource_t;
typedef int __rusage_who_t;
typedef int __priority_which_t;





extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) throw ();
# 62 "/usr/include/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) throw ();






extern int setrlimit (__rlimit_resource_t __resource,
        __const struct rlimit *__rlimits) throw ();
# 82 "/usr/include/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   __const struct rlimit64 *__rlimits) throw ();




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();





extern int getpriority (__priority_which_t __which, id_t __who) throw ();



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     throw ();

}
# 24 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2

# 1 "/usr/include/sys/mman.h" 1 3 4
# 26 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 27 "/usr/include/sys/mman.h" 2 3 4
# 42 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/include/bits/mman.h" 1 3 4
# 43 "/usr/include/sys/mman.h" 2 3 4




extern "C" {
# 58 "/usr/include/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
# 71 "/usr/include/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (__const void *__addr, size_t __len) throw ();


extern int munlock (__const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
# 134 "/usr/include/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (__const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (__const char *__name);

}
# 26 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2

# 1 "/usr/include/sys/stat.h" 1 3 4
# 103 "/usr/include/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/bits/stat.h" 1 3 4
# 36 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    unsigned short int __pad1;

    __ino_t st_ino;



    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned short int __pad2;

    __off_t st_size;



    __blksize_t st_blksize;


    __blkcnt_t st_blocks;
# 70 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 85 "/usr/include/bits/stat.h" 3 4
    unsigned long int __unused4;
    unsigned long int __unused5;



  };


struct stat64
  {
    __dev_t st_dev;
    unsigned int __pad1;

    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;

    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 127 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;
  };
# 106 "/usr/include/sys/stat.h" 2 3 4
# 207 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 226 "/usr/include/sys/stat.h" 3 4
extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, __const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 250 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));






extern int lstat (__const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/sys/stat.h" 3 4
extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, __const char *__file, __mode_t mode, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));






extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));




extern int mkfifo (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));
# 380 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
# 413 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));




extern __inline__ int
stat (__const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (3, __path, __statbuf);
}


extern __inline__ int
lstat (__const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline__ int
fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline__ int
fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline__ int
mknod (__const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline__ int
mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}





extern __inline__ int
stat64 (__const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline__ int
lstat64 (__const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline__ int
fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (3, __fd, __statbuf);
}


extern __inline__ int
fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}






}
# 28 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4
extern "C" {



# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 27 "/usr/include/bits/fcntl.h" 3 4
# 1 "/usr/include/bits/uio.h" 1 3 4
# 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 28 "/usr/include/bits/fcntl.h" 2 3 4
# 141 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };
# 208 "/usr/include/bits/fcntl.h" 3 4
extern "C" {




extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();



extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
       unsigned int __flags);



extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
       unsigned int __flags);


extern int splice (int __fdin, __off64_t *__offin, int __fdout,
     __off64_t *__offout, size_t __len, unsigned int __flags)
    throw ();


extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
    throw ();



}
# 35 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 85 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 95 "/usr/include/fcntl.h" 3 4
extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 109 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 120 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 130 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/fcntl.h" 3 4
extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off_t __offset, __off_t __len,
     int __advise) throw ();
# 188 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) throw ();
# 198 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off_t __offset, __off_t __len);
# 209 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);



}
# 29 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/include/regex.h" 1 3 4
# 29 "/usr/include/regex.h" 3 4
extern "C" {






typedef long int s_reg_t;
typedef unsigned long int active_reg_t;






typedef unsigned long int reg_syntax_t;
# 181 "/usr/include/regex.h" 3 4
extern reg_syntax_t re_syntax_options;
# 303 "/usr/include/regex.h" 3 4
typedef enum
{

  REG_ENOSYS = -1,


  REG_NOERROR = 0,
  REG_NOMATCH,



  REG_BADPAT,
  REG_ECOLLATE,
  REG_ECTYPE,
  REG_EESCAPE,
  REG_ESUBREG,
  REG_EBRACK,
  REG_EPAREN,
  REG_EBRACE,
  REG_BADBR,
  REG_ERANGE,
  REG_ESPACE,
  REG_BADRPT,


  REG_EEND,
  REG_ESIZE,
  REG_ERPAREN
} reg_errcode_t;
# 343 "/usr/include/regex.h" 3 4
struct re_pattern_buffer
{



  unsigned char *buffer;


  unsigned long int allocated;


  unsigned long int used;


  reg_syntax_t syntax;




  char *fastmap;





  unsigned char * translate;


  size_t re_nsub;





  unsigned can_be_null : 1;
# 386 "/usr/include/regex.h" 3 4
  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;
};

typedef struct re_pattern_buffer regex_t;


typedef int regoff_t;




struct re_registers
{
  unsigned num_regs;
  regoff_t *start;
  regoff_t *end;
};
# 434 "/usr/include/regex.h" 3 4
typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
} regmatch_t;





extern reg_syntax_t re_set_syntax (reg_syntax_t __syntax);




extern const char *re_compile_pattern (const char *__pattern, size_t __length,
           struct re_pattern_buffer *__buffer);





extern int re_compile_fastmap (struct re_pattern_buffer *__buffer);







extern int re_search (struct re_pattern_buffer *__buffer, const char *__string,
        int __length, int __start, int __range,
        struct re_registers *__regs);




extern int re_search_2 (struct re_pattern_buffer *__buffer,
   const char *__string1, int __length1,
   const char *__string2, int __length2, int __start,
   int __range, struct re_registers *__regs, int __stop);




extern int re_match (struct re_pattern_buffer *__buffer, const char *__string,
       int __length, int __start, struct re_registers *__regs);



extern int re_match_2 (struct re_pattern_buffer *__buffer,
         const char *__string1, int __length1,
         const char *__string2, int __length2, int __start,
         struct re_registers *__regs, int __stop);
# 502 "/usr/include/regex.h" 3 4
extern void re_set_registers (struct re_pattern_buffer *__buffer,
         struct re_registers *__regs,
         unsigned int __num_regs,
         regoff_t *__starts, regoff_t *__ends);
# 537 "/usr/include/regex.h" 3 4
extern int regcomp (regex_t *__restrict __preg,
      const char *__restrict __pattern,
      int __cflags);

extern int regexec (const regex_t *__restrict __preg,
      const char *__restrict __string, size_t __nmatch,
      regmatch_t __pmatch[],
      int __eflags);

extern size_t regerror (int __errcode, const regex_t *__restrict __preg,
   char *__restrict __errbuf, size_t __errbuf_size);

extern void regfree (regex_t *__preg);



}
# 30 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/new" 1 3
# 41 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/new" 3
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/cstddef" 1 3
# 46 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/cstddef" 3
       
# 47 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/cstddef" 3

# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 49 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 42 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/new" 2 3
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/exception" 1 3
# 40 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/exception" 3
extern "C++" {

namespace std
{
# 52 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 100 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 115 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/exception" 3
  void __verbose_terminate_handler ();
}

}
# 43 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/new" 2 3

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) throw();
}
# 82 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}
# 31 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2

# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/typeinfo" 1 3
# 40 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/typeinfo" 3
extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }
# 101 "/usr/lib/gcc/i386-redhat-linux/3.4.6/../../../../include/c++/3.4.6/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }
    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

}
# 33 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 1 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h" 1
# 13 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 26 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 27 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/bits/dlfcn.h" 1 3 4
# 58 "/usr/include/bits/dlfcn.h" 3 4
extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();

}
# 30 "/usr/include/dlfcn.h" 2 3 4
# 46 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;







extern "C" {



extern void *dlopen (__const char *__file, int __mode) throw ();



extern int dlclose (void *__handle) throw () __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      __const char *__restrict __name) throw () __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, __const char *__file, int __mode) throw ();



extern void *dlvsym (void *__restrict __handle,
       __const char *__restrict __name,
       __const char *__restrict __version)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) throw ();





typedef struct
{
  __const char *dli_fname;
  void *dli_fbase;
  __const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (__const void *__address, Dl_info *__info)
     throw () __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (__const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) throw () __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     throw () __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;
  Dl_serpath dls_serpath[1];
} Dl_serinfo;



}
# 14 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
# 28 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 28 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 129 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 24 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/sys/socket.h" 1 3 4
# 25 "/usr/include/sys/socket.h" 3 4
extern "C" {

# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4
extern "C" {


# 1 "/usr/include/bits/uio.h" 1 3 4
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count);
# 50 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count);

}
# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4





# 1 "/usr/include/bits/socket.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/bits/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 153 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 154 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/limits.h" 2 3 4
# 32 "/usr/include/bits/socket.h" 2 3 4
# 41 "/usr/include/bits/socket.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_PACKET = 10



};
# 142 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 29 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 143 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    __uint32_t __ss_align;
    char __ss_padding[(128 - (2 * sizeof (__uint32_t)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000

  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 263 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) throw ();
# 290 "/usr/include/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};


# 1 "/usr/include/asm/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 5 "/usr/include/asm/socket.h" 2 3 4
# 311 "/usr/include/bits/socket.h" 2 3 4



struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 36 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 100 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) throw ();


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();
# 124 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();






extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
         int __flags, __const struct sockaddr * __addr,
         socklen_t __addr_len);
# 161 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, __const struct msghdr *__message,
   int __flags);






extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);





extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
         __const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();
# 209 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);







extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();
# 240 "/usr/include/sys/socket.h" 3 4
}
# 25 "/usr/include/netinet/in.h" 2 3 4



extern "C" {


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 193 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t u6_addr8[16];
 uint16_t u6_addr16[8];
 uint32_t u6_addr32[4];
      } in6_u;



  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 219 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };



struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };


struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };



struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 345 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/bits/in.h" 1 3 4
# 82 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 346 "/usr/include/netinet/in.h" 2 3 4
# 354 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 366 "/usr/include/netinet/in.h" 2 3 4
# 428 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();
# 456 "/usr/include/netinet/in.h" 3 4
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };




extern int inet6_option_space (int __nbytes)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) throw () __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    __const uint8_t *__typep, int __multx,
    int __plusy) throw () __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_next (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_find (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     throw () __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) throw ();
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) throw ();
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     throw ();
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();



extern socklen_t inet6_rth_space (int __type, int __segments) throw ();
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) throw ();
extern int inet6_rth_add (void *__bp, __const struct in6_addr *__addr) throw ();
extern int inet6_rth_reverse (__const void *__in, void *__out) throw ();
extern int inet6_rth_segments (__const void *__bp) throw ();
extern struct in6_addr *inet6_rth_getaddr (__const void *__bp, int __index)
     throw ();





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     throw ();


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    __const struct in_addr *__slist)
     throw ();



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) throw ();


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       __const struct sockaddr_storage *__slist) throw ();


}
# 29 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/3.4.6/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (__const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) throw ();


}
# 34 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 39 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/netdb.h" 1 3 4
# 27 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 44 "/usr/include/netdb.h" 2 3 4
# 54 "/usr/include/netdb.h" 3 4
extern "C" {






extern int *__h_errno_location (void) throw () __attribute__ ((__const__));
# 88 "/usr/include/netdb.h" 3 4
extern void herror (__const char *__str) throw ();


extern __const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;

};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (__const char *__name);
# 149 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (__const char *__name, int __af);
# 161 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (__const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (__const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 192 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (__const char *__name);
# 231 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (__const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (__const char *__name,
          __const char *__proto);






extern struct servent *getservbyport (int __port, __const char *__proto);
# 303 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (__const char *__restrict __name,
       __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (__const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 369 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (__const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 390 "/usr/include/netdb.h" 3 4
extern int setnetgrent (__const char *__netgroup);







extern void endnetgrent (void);
# 407 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 418 "/usr/include/netdb.h" 3 4
extern int innetgr (__const char *__netgroup, __const char *__host,
      __const char *__user, __const char *domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 446 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   __const char *__restrict __locuser,
   __const char *__restrict __remuser,
   __const char *__restrict __cmd, int *__restrict __fd2p);
# 458 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      __const char *__restrict __locuser,
      __const char *__restrict __remuser,
      __const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 474 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    __const char *__restrict __name,
    __const char *__restrict __pass,
    __const char *__restrict __cmd, int *__restrict __fd2p);
# 486 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       __const char *__restrict __name,
       __const char *__restrict __pass,
       __const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 500 "/usr/include/netdb.h" 3 4
extern int ruserok (__const char *__rhost, int __suser,
      __const char *__remuser, __const char *__locuser);
# 510 "/usr/include/netdb.h" 3 4
extern int ruserok_af (__const char *__rhost, int __suser,
         __const char *__remuser, __const char *__locuser,
         sa_family_t __af);
# 522 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 531 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};
# 631 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (__const char *__restrict __name,
   __const char *__restrict __service,
   __const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern __const char *gai_strerror (int __ecode) throw ();





extern int getnameinfo (__const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, unsigned int __flags);
# 661 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
     int __ent, struct sigevent *__restrict __sig);
# 672 "/usr/include/netdb.h" 3 4
extern int gai_suspend (__const struct gaicb *__const __list[], int __ent,
   __const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();


}
# 15 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h" 2
# 26 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h"
struct mpi_portal_status {
  int MPI_SOURCE;
  int MPI_TAG;
  int MPI_ERROR;

  unsigned char real_status[64];
};

struct mpi_portal_request {

  unsigned char real_request[64];
};
# 54 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h"
struct mpi_portal_t {
  int version;
  const char *revision;
  const char *name;
  const char *build_info;
  int (*_MPI_Init)(int *pargc, char ***pargv);
  int (*_MPI_Error_string)(int errcode, char *msg, int *plen);
  int (*_MPI_Barrier)(int comm);
  int (*_MPI_Comm_rank)(int comm, int *rank);
  int (*_MPI_Comm_size)(int comm, int *psize);
  int (*_MPI_Finalize)(void);
  int (*_MPI_Get_count)(struct mpi_portal_status *stat, int dtype, int *count);
  int (*_MPI_Iprobe)(int src,int tag,int comm,int *flag,
       struct mpi_portal_status *stat);
  int (*_MPI_Recv)(void *buf, int count, int dtype,
    int src, int tag, int comm, struct mpi_portal_status *stat);
  int (*_MPI_Send)(void *buf, int count, int dtype, int dest,
    int tag, int comm);
  int (*_MPI_Isend)(void *buf, int count, int dtype,int dest,
                  int tag, int comm, struct mpi_portal_request *req);
  int (*_MPI_Test)(struct mpi_portal_request *req, int *flag, struct mpi_portal_status *stat);
  int (*_MPI_Wait)(struct mpi_portal_request *req, struct mpi_portal_status *stat);
  double (*_MPI_Wtime)(void);
  int (*_DMPI_Levels)(void);
  int (*_DMPI_Id)(int level, int rank);

  int (*_DMPI_Async_init)(void);
  void (*_DMPI_Async_done)(void);
  int *(*_DMPI_Async_in_handler)(void);
  int (*_DMPI_Async_enable)(void);
  int (*_DMPI_Async_disable)(void);
  int (*_DMPI_Async_ping)(int);
  int (*_DMPI_Async_set_handler)(void (*handler)(void));
};


extern char dmpi_so[1024];
extern int dmpi_meta;
# 102 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h"
extern struct mpi_portal_t *mpi_portal;
# 145 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../dmpi/dmpi.h"
extern "C" {

 extern int MPI_Init (int *a, char ***b);


}
# 34 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt" 2
# 68 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
namespace ts {
extern int myRank;
};
# 79 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
extern "C" {
char *__cxa_demangle (const char *__mangled_name, char *__output_buffer, size_t *__length, int *__status);
}
namespace ts {
# 107 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
typedef struct { volatile int counter; } atomic_t;
# 134 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ void atomic_add(int i, atomic_t *v)
{
 __asm__ __volatile__(
  "" "addl %1,%0"
  :"=m" (v->counter)
  :"ir" (i), "m" (v->counter));
}
# 149 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ void atomic_sub(int i, atomic_t *v)
{
 __asm__ __volatile__(
  "" "subl %1,%0"
  :"=m" (v->counter)
  :"ir" (i), "m" (v->counter));
}
# 166 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
{
 unsigned char c;
 __asm__ __volatile__(
  "" "subl %2,%0; sete %1"
  :"=m" (v->counter), "=qm" (c)
  :"ir" (i), "m" (v->counter) : "memory");
 return c;
}







static __inline__ void atomic_inc(atomic_t *v)
{
 __asm__ __volatile__(
  "" "incl %0"
  :"=m" (v->counter)
  :"m" (v->counter));
}







static __inline__ void atomic_dec(atomic_t *v)
{
 __asm__ __volatile__(
  "" "decl %0"
  :"=m" (v->counter)
  :"m" (v->counter));
}
# 212 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ int atomic_dec_and_test(atomic_t *v)
{
 unsigned char c;
 __asm__ __volatile__(
  "" "decl %0; sete %1"
  :"=m" (v->counter), "=qm" (c)
  :"m" (v->counter) : "memory");
 return c != 0;
}
# 230 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ int atomic_inc_and_test(atomic_t *v)
{
 unsigned char c;
 __asm__ __volatile__(
  "" "incl %0; sete %1"
  :"=m" (v->counter), "=qm" (c)
  :"m" (v->counter) : "memory");
 return c != 0;
}
# 249 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static __inline__ int atomic_add_negative(int i, atomic_t *v)
{
 unsigned char c;
 __asm__ __volatile__(
  "" "addl %2,%0; sets %1"
  :"=m" (v->counter), "=qm" (c)
  :"ir" (i), "m" (v->counter) : "memory");
 return c;
}
# 271 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
struct thr_struct {
  pthread_t th;
  unsigned long stack_top;
  unsigned long stack_bottom;
};
extern int _thread_ncpu;
int get_cputhread_stack_size();
# 287 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static inline int thread_ncpu() { return 1; }




static inline int thread_self() { return 0; }
# 301 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
static inline bool tsLocked() { return true; }

extern int thread_initialized;
template <typename type>
class ThreadLocal
{
private:
  type data[1];
public:
  ThreadLocal() {}
  ThreadLocal(const type& val) {
    for (int i = 0; i < thread_ncpu(); i++) data[i] = val;
  }
  inline type& operator[] (int th_idx) { return data[th_idx]; }
  inline const type& operator[] (int th_idx) const { return data[th_idx]; }
  inline type& operator() () { return (*this)[thread_self()]; }
  inline const type& operator() () const { return (*this)[thread_self()]; }
};
unsigned long get_thread_stack_top();
unsigned long get_thread_stack_bottom();
class Atomic {
private:
  atomic_t cnt;
public:
  Atomic(int _cnt) { *this = _cnt; }
  inline operator int () const { return ((&cnt)->counter); }
  inline void operator = (int _cnt) { (((&cnt)->counter) = (_cnt)); }
  inline void operator++ () { atomic_inc(&cnt); }
  inline bool operator-- () { return !atomic_dec_and_test(&cnt); }
};
class Spinlock : Atomic {
public:
  Spinlock() : Atomic(1) {}
  inline void lock() {
    while (1) {
      if ((int)(*this) != 1) continue;
      if (!--(*this)) return;
      ++(*this);
    }
  }
  inline bool try_lock() { return (--(*this)) ? (++(*this),false) : true; }
  inline void unlock() { ++(*this); }
  class Locker {
  public:
    Spinlock *sl;
    Locker(Spinlock *_sl) : sl(_sl) { sl->lock(); }
    ~Locker() { sl->unlock(); }
  };
};
# 483 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class TSLock {
public:
  inline void lock() { }
  inline void unlock() { }
  inline void save(int &state) { }
  inline void restore(const int &state) { }
  inline int get_level() { return 1; }
};
extern TSLock tsLock;
class TSLocker { };
class TSLockCleaner { };






char *demangle(const char* name);
const char *fileInfo(const char *file, const char *pat1, const char *pat2, const char *patTerm);
int cpuCount();
void fault();
class ACnt {
public:
  Atomic cnt;
  ACnt() : cnt(0) {}
  inline bool operator-- () {
    return --cnt ? true : (onZero(),false);
  }
  inline void operator++ () {
    ++cnt;
  }
  virtual void onZero() {}
};
class ARef {
private:
  inline void ctor(ACnt *_a) { a = _a; if (a) ++(*a); }
  inline void dtor() { if (a) { --(*a); a = __null; } }
  inline void cdtor(ACnt *_a) {
    ACnt *p = a;
    a = _a; if (a) ++(*a);
    if (p) --(*p);
  }
protected:
  ACnt *a;
public:
  inline ARef (ACnt* a = __null) { ctor(a); }
  inline ARef (const ARef &ar) { ctor(ar.a); }
  inline ACnt* operator= (ACnt *_a) {
    if (a != _a) { cdtor(_a); }
    return a;
  }
  inline ACnt* operator= (ARef& ar) {
    if (a != ar.a) { cdtor(ar.a); }
    return a;
  }
  inline ~ARef() { dtor(); }
};
# 556 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class String {
  struct StrLevel {
    typeof(char[0x40000]) buf;
    char* p;
    void rewind() { p = buf; }
    int left() { return buf + sizeof(buf) - p; }
  };
  static StrLevel lvls[8];
  static StrLevel *openl, *curl;
  char* p;
public:
  static void rewind() { curl = __null; }
  String() { open(); }
  String(const char *format, ...) {
    open();
    va_list args;
    __builtin_va_start(args,format);
    p += vsnprintf(p,curl->left(),format,args);
    __builtin_va_end(args);
  }
  char *open() {
    if (curl == __null) curl=openl=lvls-1;
    if (++curl > openl) {
      (++openl)->rewind();
      {if (!(openl < lvls + 8)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "openl < lvls + levels" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",580); ((int*)0)[0]=0;}};
    }
    return (p = curl->p);
  }
  inline char operator* () { return *p; }
  inline operator char* () { return p; }
  inline char* operator ++() { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",586); ((int*)0)[0]=0;}}; return ++p; }
  inline char* operator ++(int) { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",587); ((int*)0)[0]=0;}}; return p++; }
  size_t printf (const char *format, ...) {
    va_list args;
    __builtin_va_start(args,format);
    size_t n = vsnprintf(p,curl->left(),format,args);
    p += n;
    __builtin_va_end(args);
    return n;
  }
  char *close(int reserve = 0) {
    char *ret = curl->p;
    *p++ = 0; curl->p = p + reserve;
    {if (!(curl->left() > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "curl->left() > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",599); ((int*)0)[0]=0;}};
    curl--; p = __null;
    return ret;
  }
  ~String() {
    if (p) close();
  }
};

typedef String VizStr;


enum Color { Black, Red, Green, Yellow, Blue, Magenta, Cyan, White };
inline Color bright (Color c) { return (Color)(c | 8); }



class UserInterface : Spinlock {
public:
  bool colorCapable;
  virtual int write (Color color, const char *what) {
    VizStr s;
    char colorFormat[] = "\033[0;30m%s\033[0;39m";
    colorFormat[2] += color >>3;
    colorFormat[5] += color & 7;
    int l = s.printf(colorCapable ? colorFormat : "%s", what);
    char *p = s.close();
    Locker x(this);
    return ::write(2,p,l);
  }
  UserInterface();
  virtual ~UserInterface() {}

  virtual const char* ask (const char* prompt) {
    VizStr s("\n\n * INPUT AWAITED * \n\n %s", prompt);
    Locker x(this);
    write(Yellow, s.close());
    char *p = s.open();
    int l = ::read(0, p, 1024);
    {if (!(l >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "l >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",638); ((int*)0)[0]=0;}};
    p[l] = 0;
    return s.close(1024);
  }
};
extern UserInterface* ui;
extern int myRank, superSize, mainRank,realsuperSize;
# 653 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class Viz {
public:
  class Vid {
  public:
    char text[12];
    Vid() { text[0] = 0; }
    void operator= (const char *_text) { *this = *(Vid*)_text; }
  } vid;
  virtual const char* viz() {
    VizStr v("%s%s%.*s @%p", demangle(typeid(*this).name()), vid.text[0] ? "/":"", sizeof(vid),vid.text, this);
    return v.close();
  }
  static regex_t rx;
  static void setVizOption(const char *opt) {
      if (regcomp (&rx, opt, 1)) {
              do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Regexp `%s' compilation failed!\n", opt); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
      }
  };
  class DefaultVizOption {
  public:
     DefaultVizOption(const char *opt) {
       setVizOption(opt);
    }
  };
   static void vpp( int , const char * msg, const char *module, const char * pretty_function, const char * function)
  {
    VizStr hidstr("module=%s,method=%s",module,pretty_function);
    if ( (0==regexec(&rx,hidstr.close(),0,__null,0)) || (0==regexec(&rx,msg,0,__null,0)) )
    {
      VizStr out ("[%d|%s|%s>   %s\n",myRank,module,function,msg);
      ui->write(((Color)((myRank%4)+Green)),out.close());
    };
  };
};
class Ring {
  Ring *prev,*next;
public:
  inline void ok() {







  }
  inline void ct() { prev = next = this; }
  inline Ring() { ct(); }
  inline bool ringEmpty() { return next == this; }
  inline Ring* first() { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",702); ((int*)0)[0]=0;}}; return ringEmpty() ? __null : next; }
  inline Ring* last() { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",703); ((int*)0)[0]=0;}}; return ringEmpty() ? __null : prev; }
  inline Ring* popFront() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",705); ((int*)0)[0]=0;}};
    Ring* e = ringEmpty() ? __null : next->remove();
    ok();
    return e;
  }
  inline Ring* getFront() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",711); ((int*)0)[0]=0;}};
    Ring* e = ringEmpty() ? __null : next;
    ok();
    return e;
  }
  inline Ring* popBack() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",717); ((int*)0)[0]=0;}};
    Ring* e = ringEmpty() ? __null : prev->remove();
    ok();
    return e;
  }
  inline Ring* getBack() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",723); ((int*)0)[0]=0;}};
    Ring* e = ringEmpty() ? __null : prev;
    ok();
    return e;
  }
  inline void pushFront(Ring& t) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",729); ((int*)0)[0]=0;}};
    if (!t.ringEmpty())
      t.remove();



    t.prev = this; t.next = next;
    next->prev = &t; next = &t;
    ok();
  }
  inline void pushBack(Ring& t) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",740); ((int*)0)[0]=0;}};
    if (!t.ringEmpty())
      t.remove();



    t.next = this; t.prev = prev;
    prev->next = &t; prev = &t;
    ok();
  }
  Ring* remove() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",751); ((int*)0)[0]=0;}};



    prev->next = next;
    next->prev = prev;
    next = prev = this;
    ok();
    return this;
  }
  ~Ring() { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",761); ((int*)0)[0]=0;}}; if (!ringEmpty()) remove(); }
};
void idleWait();






class Service {
  int index;
public:
  static Service* service[5];
  static ThreadLocal<bool> exitFlag;
  static Atomic threadExited;
  static int exitError;
  Service(const char *name,int prio) : index(prio) {
    {if (!(service[index] == __null)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "service[index] == NULL" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",778); ((int*)0)[0]=0;}};
    service[index] = this; ;
  }
  virtual ~Service() { service[index] = __null; }
  static void exitThread() {
    exitFlag() = true;
  }
  static void exitServices(int error) {
    exitError=error;
    for (int i = 0; i < thread_ncpu(); i++) {
      exitFlag[i] = true;
    }
  };
  static void doAllWork() {
    while (!exitFlag()) {
      int i;
      for (i = 0; i < 5; i++) if (service[i] && service[i]->work()) break;
      if (i == 5) idleWait();
    }
  }
  virtual bool work() = 0;
};
class Delay {
public:
  Delay *next;
  Delay():next(__null) {}

  void operator()(Delay*& p) {
    if (p == ((Delay*)-1)) delete this;
    else { next = p; p = this; }
  }
  static void force(Delay*& me) {
    if (me == __null || me == ((Delay*)-1)) return;
    force(me->next); delete me; me = ((Delay*)-1);
  }

  virtual ~Delay() {}
};
class GlobalConfig {
public:




  bool showMsgs;
  bool generateCallGraph;
  bool showFeatures;
  bool enableAsync;
  int ncpu;
  bool autoCcall;
  GlobalConfig():



    showMsgs(false),generateCallGraph(false),showFeatures(false), enableAsync(false),
    ncpu(1), autoCcall(false) {
  }
};
extern GlobalConfig conf;
class FinalizeException {};
class SContext {
public:
  int nodePrio;
  SContext(): nodePrio(0) {}
};
class SchedContext {
public:
};
class TContext : public SContext, public SchedContext {
public:
  int prio;
  int mflops;
  int mbytes;
  int pflags;
  int fflags;
  int atRank;
  double cpuUsage;
  int extraSize;
  int stackSizeLg;
  bool memoize;
  TContext() : prio(0), mflops(-15), mbytes(-10),
        pflags(0), fflags(0), atRank(-1), cpuUsage(1.), extraSize(0), stackSizeLg(15),memoize(false) {}
};
extern ThreadLocal<TContext> _tc;
static inline TContext& tc() { return _tc(); }






class mrefMagneticTrigger {
  int saved;
 public:
  mrefMagneticTrigger(int n) : saved(tc().pflags & 2) {
         {if (!((n==0) || (n==1))) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "(n==0) || (n==1)" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",873); ((int*)0)[0]=0;}};
         if (n)
               tc().pflags |= 2;
         else
               tc().pflags &= ~2;
  }
  ~mrefMagneticTrigger() {
         if (saved) {
               tc().pflags |= 2;
         } else {
               tc().pflags &= ~2;
         }
  }
};

class mrefGlueTrigger {
  int saved;
 public:
  mrefGlueTrigger(int n) : saved(tc().pflags & 1) {
         {if (!((n==0) || (n==1))) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "(n==0) || (n==1)" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",892); ((int*)0)[0]=0;}};
         if (n)
               tc().pflags |= 1;
         else
               tc().pflags &= ~1;
  }
  ~mrefGlueTrigger() {
         if (saved) {
               tc().pflags |= 1;
         } else {
               tc().pflags &= ~1;
         }
  }
};

class cpuUsageTrigger {
  double savedCpuUsage;
public:
  cpuUsageTrigger(double n) : savedCpuUsage(tc().cpuUsage) { tc().cpuUsage = n; }
  ~cpuUsageTrigger() { tc().cpuUsage = savedCpuUsage; }
};

class atRankTrigger {
  int savedAtRank;
 public:
  atRankTrigger(int n) : savedAtRank(tc().atRank) { tc().atRank = n; }
  ~atRankTrigger() { tc().atRank = savedAtRank; }
};

class extraSizeTrigger {
  int savedExtraSize;
 public:
  extraSizeTrigger(int n) : savedExtraSize(tc().extraSize) { tc().extraSize = n; }
  ~extraSizeTrigger() { tc().extraSize = savedExtraSize; }
};

class priorityTrigger {
  int savedPriority;
 public:
  priorityTrigger(int n) : savedPriority(tc().prio) { tc().prio = n; }
  ~priorityTrigger() { tc().prio = savedPriority; }
};

class stackSizeTrigger {
  int savedStackSizeLg;
 public:
  stackSizeTrigger(int lg) : savedStackSizeLg(tc().stackSizeLg) { tc().stackSizeLg = lg; }
  ~stackSizeTrigger() { tc().stackSizeLg = savedStackSizeLg; }
};

class memoizeTrigger {
  bool savedState;
 public:
  memoizeTrigger(bool state) : savedState(tc().memoize) { tc().memoize = state; }
  ~memoizeTrigger() { tc().memoize = savedState; }
};






class WTimer
{
private:
  double frequency;
  inline void getCpuInfo() {

    const char* buf = fileInfo("/proc/cpuinfo","cpu MHz",": ","\n");
    if (!buf)
      frequency=0;
    else
      frequency=1/(double)(atof(buf)*1000000);



  }
public:
  WTimer() { getCpuInfo(); }
  double wTime() { return tickTime()*frequency; }
  unsigned long long sec2Tick(double time) { return (unsigned long long)(time/frequency); }
  double tick2Sec(unsigned long long time) { return time*frequency; }
  inline unsigned long long tickTime() {
    unsigned long long tmp;


    asm volatile ( "rdtsc\n\t"
     : "=A" (tmp) );
# 991 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    return tmp;
  }
};
unsigned long long tickTime();
double tick2Sec(unsigned long long);
double wTime();
class Prof {
public:
  long long total;
  long long startAt;
  void reset() {
    total = 0;
    startAt = 0;
  }
  inline Prof() : total(0),startAt(0) {
    ;
  }
  void start() { startAt = tickTime(); }
  long long stop() {
    long long timeLeft;
    if (!startAt) {
      timeLeft = 0;
    } else {
      timeLeft = tickTime() - startAt;
      total += timeLeft;
    }
    startAt = 0;
    return timeLeft;
  }
  long long stopStart() {
    long long timeLeft;
    long long tmp;
    if (!startAt) {
      startAt = tickTime();
      return 0;
    }
    tmp = tickTime();
    timeLeft = tmp - startAt;
    total += timeLeft;
    startAt = tmp;
    return timeLeft;
  }
  virtual const char *codeId() { return "<unnamed>"; }
  class Timer {
  public:
    Prof *p;
    Timer(Prof& _p) : p(&_p) { p->start(); }
    long finish() { return p->stop(); }
    ~Timer() { finish(); }
  };
};
struct StatisticValues {
  long long time;
  long msg_count;
  long msg_size;
  long evt_count;
  long async_msg_count;
  StatisticValues& operator+=(const StatisticValues& b) {
    time += b.time;
    msg_count += b.msg_count;
    async_msg_count += b.async_msg_count;
    msg_size += b.msg_size;
    evt_count += b.evt_count;
    return *this;
  }
  void reset() {
    msg_count = 0;
    async_msg_count = 0;
    msg_size = 0;
    evt_count = 0;
    time = 0;
  }
  StatisticValues() {
    reset();
  }
  static ThreadLocal<StatisticValues> currentValues;
};
class Task;
class TaskStatistic : public StatisticValues {
public:
  static ThreadLocal<Prof> prof;
  TaskStatistic* upStat;
  long long statId;
  TaskStatistic(TaskStatistic* upStat_, long long sysTaskId_) : upStat(upStat_), statId(sysTaskId_) {}
  void enter(TaskStatistic *from) {
    if (statId<=-10)
      upStat = from;
    prof().start();
    evt_count++;
  }
  void addStatistic() {
    StatisticValues& cur = currentValues();
    TaskStatistic* curp = this;
    while (curp) {
      *curp += cur;
      curp = curp->upStat;
    }
    cur.reset();
  }
   void leave() {
    int me = thread_self();
    {if (!(me || true)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "me || true" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1092); ((int*)0)[0]=0;}};
    currentValues[me].time += prof[me].stop();
    addStatistic();
  }
  void switchStatistic(TaskStatistic* t)
  {
    int me = thread_self();
    {if (!(me || true)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "me || true" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1099); ((int*)0)[0]=0;}};
    currentValues[me].time += prof[me].stopStart();
    addStatistic();
    if (t->statId<=-10)
      t->upStat = this;
    t->evt_count++;
   }
  class Holder {
    Task* saved_current;
  public:
    Holder(Task* t);
    ~Holder();
  };
};
extern Task mpiTask;



struct Statistic {
public:
  bool alive;
  long long tasksActivated;
  long long tasksExported;
  long long msgsSent;
  long long msgsAsyncSent;
  long long msgsSize;
  double total_time;
  double tasks_time;
  double idle_time;
  double sched_time;
  double mpi_time;
  int visit_count;
  Statistic() : alive(true), tasksActivated(0), tasksExported(0), msgsSent(0), msgsAsyncSent(0), mpi_time(0.), visit_count(0) {}
};
extern Statistic *myStat;

class CmdLine {
public:
  static int *mainArgc;
  static char** *mainArgv;
  static int extArgc;
  static char** extArgv;
  static Delay *delay;
  CmdLine(int* argc, char** *argv) {
    mainArgc = argc;
    mainArgv = argv;
    extArgc = 0;
    extArgv = (char **) malloc(*argc * sizeof(int));
    ProcessCmdLine();
    Delay::force(delay);
  }
  ~CmdLine() {
    for (int i = 0; i < extArgc; i ++)
      free(extArgv[i]);
    free(extArgv);
  }
  void ProcessCmdLine()
  {
    int i;
    int tct_count=0;
    bool tct_prev=false;
    for (i=1; i<*mainArgc ; i++)
    {
      if (tct_prev) {
 ProcessTCTOption((*mainArgv)[i]);
 tct_prev=false;
 tct_count++;
      } else if ( strcmp("-tct", (*mainArgv)[i] )==0) {
       tct_count++;
       tct_prev=true;
      } else {
 (*mainArgv)[i-tct_count]=(*mainArgv)[i];
      }
    }
    *mainArgc -= tct_count;
  }
  void ProcessTCTOption(char *option) {
    int opt_len;
    opt_len=strlen(option);
    {if (!(opt_len<512)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "opt_len<512" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1178); ((int*)0)[0]=0;}};
    if ((strncmp("DP(\"",option,4)==0) && (strncmp("\")",option+opt_len-2,2)==0)) {
      char opt[1024]={0,};
      memcpy(opt,option+4,opt_len-6);
      Viz::setVizOption(opt);
    } else if (strcmp(option,"callGraph")==0) {



      conf.generateCallGraph = true;

    } else if (strcmp(option,"showMsgs")==0) {
      conf.showMsgs = true;
    } else if (strcmp(option,"showFeatures")==0) {
      conf.showFeatures = true;
    } else if (strcmp(option,"enableAsync")==0) {
      conf.enableAsync = true;
    } else if (strcmp(option,"disableAsync")==0) {
      conf.enableAsync = false;
    } else if (strcmp(option,"enableSMP")==0) {
      conf.ncpu = cpuCount();
    } else if (strncmp(option,"ncpu=",5)==0) {
      conf.ncpu = atoi(option + 5);
      {if (!(conf.ncpu >= 1)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "conf.ncpu >= 1" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1201); ((int*)0)[0]=0;}};
      {if (!(conf.ncpu <= 1)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "conf.ncpu <= MAXCPU" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1202); ((int*)0)[0]=0;}};
    } else {
      extArgv[extArgc] = strdup(option);
      extArgc ++;
    }
  }
};
typedef void* (*entry_t)(int cmd, void *arg);
extern "C" {
void registerFeature(const char *name, const char *comment, entry_t entry);
entry_t featureEntry(const char *name);
}
class Feature {
  Feature *next;
  entry_t entry;
  const char *name;
  const char *comment;
  const char *status;
  bool internal;
  static Feature *all;
public:
  Feature(const char *_name, const char *_comment, bool _internal = true, entry_t _entry = __null) :
    next(all), entry(_entry), name(_name), comment(_comment), status(__null), internal(_internal) {
    all = this;
  }
  inline const char* error() { return (status && !strncmp(status,"ERROR",5)) ? status+5 : __null; }
  static entry_t getEntry(const char *name) {
    Feature *f;
    for (f = all; f; f = f->next) if (!f->error() && !strcmp(f->name,name)) return f->entry;
    return __null;
  }
  void doInitialize() {
    if (verbose()) do { { VizStr msgstr("  %s (%s)", name, comment); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    if (entry) status = (const char*)(*entry)(0, __null);
    if (status && verbose()) {
      if (error()) do { { VizStr msgstr(": %s [disabled]", error()); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0);
      else do { { VizStr msgstr(": %s", status); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    }
    if (verbose()) do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    if (internal && error()) do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Internal feature failed\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
  }
  static void initialize(const char *msg, bool internal) {
    if (verbose()) do { { VizStr msgstr("%s\n", msg); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    Feature *f;
    for (f = all; f; f = f->next) if (f->internal == internal) f->doInitialize();
  }
  static void initialize() {
    initialize("Internal features: ", true);
    initialize("External features: ", false);
  }
  static bool verbose() { return conf.showFeatures; }
};
class Freezer {
  static ThreadLocal<int> count;
public:
  static inline bool isOn() {
    {if (!(count() >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "count() >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1258); ((int*)0)[0]=0;}};
    return count() > 0;
  }
  inline Freezer() {
    count()++; ;
  }
  inline ~Freezer() {
    count()--; ;
    {if (!(count() >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "count() >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1266); ((int*)0)[0]=0;}};
  }
  class TemporaryOff {
    int saved_count;
public:
    TemporaryOff() : saved_count(count()) { count() = 0; }
   ~TemporaryOff() { count() = saved_count; }
  };
};


class SystemMemoryAllocator {
public:
  void* alloc(size_t size) { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1279); ((int*)0)[0]=0;}}; return ::malloc(size); }
  void free(void* data) { {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1280); ((int*)0)[0]=0;}}; ::free(data); }
};
extern SystemMemoryAllocator memoryAllocator;
template <class T>
class DataAllocator {
public:
  virtual T* alloc(size_t size = sizeof(T)) {
    {if (!(size >= sizeof(T))) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "size >= sizeof(T)" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1287); ((int*)0)[0]=0;}};
    return (T*)memoryAllocator.alloc(size);
  }
  virtual void free(T* t) { memoryAllocator.free(t); }
  virtual ~DataAllocator() {}
};
class Header;
extern DataAllocator<Header> *pdataAllocator;

template <class T, unsigned int HSIZE = 65536, unsigned int SHIFT = 4>
class DataAllocatorCache : public DataAllocator<T> {
private:
  class DataAllocatorHeader : public Ring {
  private:
    size_t size;
  public:
    inline DataAllocatorHeader () { ct(0); }
    inline void ct (size_t _size) { size = _size; Ring::ct(); }
    inline size_t get_size () const { return size; }
  };
  DataAllocatorHeader headFree[HSIZE];



  DataAllocator<DataAllocatorHeader> allocator;
protected:
  inline DataAllocatorHeader* allocHeader(size_t size) {
    return allocator.alloc(sizeof(DataAllocatorHeader) + size);
  }
  inline void freeHeader(DataAllocatorHeader* h) {
    allocator.free(h);
  }
  void flush () {
    unsigned int i;
    for (i = 0; i < HSIZE; i++) {
      while (!headFree[i].ringEmpty()) {
        DataAllocatorHeader *r = (DataAllocatorHeader*)headFree[i].popFront();
        freeHeader(r);
      }







    }







  }
  inline int get_idx(size_t size) { return size?((size-1) >> SHIFT):0; }
public:
  virtual T* alloc(size_t size = sizeof(T)) {
    DataAllocatorHeader *r;
    unsigned int idx = get_idx(size);
    size_t realSize = (idx+1) << SHIFT;
    if (idx < HSIZE) {
      if (!headFree[idx].ringEmpty()) {
        r = (DataAllocatorHeader*)headFree[idx].popFront();
      } else {
        r = allocHeader(realSize);
      }
      r->ct(size);



    } else {
      r = allocHeader(realSize);
      r->ct(size);



    }
    T* t = (T*)(((char*)r)+sizeof(DataAllocatorHeader));
    return t;
  }
  virtual void free(T* t) {
    DataAllocatorHeader *r = (DataAllocatorHeader*)(((char*)t)-sizeof(DataAllocatorHeader));



    size_t size = r->get_size();
    unsigned int idx = get_idx(size);
    if (idx < HSIZE) {
      headFree[idx].pushFront(*r);
    } else {
      freeHeader(r);
    }
  }
  virtual ~DataAllocatorCache() { flush (); }
};
extern DataAllocatorCache<Header> dataAllocatorCache;

class StackAllocator {
private:
  unsigned long stack_addr;
  unsigned long stack_begin;
  size_t page_size;
public:
  void init_stack()
  {
    stack_addr = get_thread_stack_top();
    stack_begin = get_thread_stack_bottom();
    stack_addr -= 1 << 15;



  }
  StackAllocator() {
    page_size = getpagesize();
  }
  void* alloc(size_t size) {
    {if (!(size > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "size > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1404); ((int*)0)[0]=0;}};



    stack_addr -= size;
    if (stack_addr <= stack_begin) do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Stack overflow\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
    ;





    return (void*)(stack_addr);

  }
  void free(void* data) {
    ;
  }
};
extern ThreadLocal<StackAllocator> stackAllocator;
template <class T>
class ThreadAllocator {
private:
  Ring head[3][20];
public:
  T* alloc(int prio, int stackSizeLg) {
    {if (!(stackSizeLg > 0 && stackSizeLg < 20)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "stackSizeLg > 0 && stackSizeLg < TC_MAX_STACK_LG" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1430); ((int*)0)[0]=0;}};
    {if (!(prio >= 0 && prio < 3)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "prio >= 0 && prio < TC_MAX_PRIO" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1431); ((int*)0)[0]=0;}};
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1432); ((int*)0)[0]=0;}};
    if (head[prio][stackSizeLg].ringEmpty())
      return new T(prio,stackSizeLg);
    else
      return (T*)head[prio][stackSizeLg].popFront();
  }
  void free(T* t) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1439); ((int*)0)[0]=0;}};
    head[t->prio][t->stackSizeLg].pushFront(*t);
    t->reinit();
  }
};
class SThread;
typedef ThreadAllocator<SThread> SThreadAllocator;
extern ThreadLocal<SThreadAllocator> threadAllocator;
# 1466 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class ThrH {
public:
  friend class ThrQ;
  friend class ThrQS;
  typedef void (*proc_t)(void*);
private:
  void *stk; proc_t proc; void *arg;
  ThrH *next;
  double readyTime;



public:
  int tsLockLevel;
  int cpu;
  void *stkMin;
  void *initStk;
  inline ThrH(): stk(__null),proc(__null),arg(__null),next(__null),readyTime(0),tsLockLevel(1),cpu(-1),stkMin((void*)-1) {



  };
  inline static ThrH* self() {
    ThrH* ath = active_thread();
    {if (!(ath)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "ath" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1490); ((int*)0)[0]=0;}};
    return ath;
  }
  static void spawn(ThrH* child, proc_t func, void *arg);
  static void sleep(double sec);
  inline void initProc(proc_t _proc, void *_arg) {
    proc = _proc;
    arg = _arg;
    stk = initStk;
  }
  inline static void yield (ThrH* to) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1501); ((int*)0)[0]=0;}};
    ThrH* from = self();
    if (from != to) {
      if (to->proc) to->stk = to->initStk;
      {if (!(!to->next)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!to->next" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1505); ((int*)0)[0]=0;}};
      {if (!(to->cpu == thread_self())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "to->cpu == thread_self()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1506); ((int*)0)[0]=0;}};



      active_thread() = to;



      hwSaveRestore(from,to);
      {if (!((unsigned long)from->stk > (unsigned long)from->stkMin)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "(unsigned long)from->stk > (unsigned long)from->stkMin" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1515); ((int*)0)[0]=0;}};
    }
  }
private:
  static ThreadLocal<ThrH*> active_thread;
  static void hwSaveRestore(ThrH* save, ThrH* restore, void* dummy = __null);
};
class ThrQ {
  friend class ThrH;
  friend class ThrQS;
  ThrH* head;
public:
  inline ThrQ() : head(__null) {};
  inline ThrH* pop() {
    ThrH *th = head;
    if (th) { head = th->next; th->next = __null; }
    return th;
  }
  inline void push(ThrH* th) {
    {if (!(th && !th->next)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "th && !th->next" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1534); ((int*)0)[0]=0;}};
    th->next = head;
    head = th;
  }
  void contTasks(bool delay = true);
  void stopHereAndRunOthers();
};
class ThrQS {
  friend class ThrQ;
public:
  ThrQ running, delayed, sleeping;
  ThrH main;
  void init() {
    ThrH::active_thread() = &main;
    main.stkMin = 0;
    main.cpu = thread_self();



  }
  inline bool hasReadyThreads() {
    return running.head || delayed.head || (sleeping.head && sleeping.head->readyTime <= wTime());
  }
  inline ThrH* popNextActiveThread() {
    ThrH* t = running.pop();
    if (!t) t = delayed.pop();
    if (!t) if (sleeping.head && sleeping.head->readyTime <= wTime()) t = sleeping.pop();
    if (!t) t = &main;
    return t;
  }
  inline void run() {
    {if (!(ThrH::self() == &main)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "ThrH::self() == &main" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1565); ((int*)0)[0]=0;}};
    ThrH::yield(popNextActiveThread());
  }
  static ThreadLocal<ThrQS> tqs;
};
long long myMemLimit();
class Task;
class SThread : public Ring {
private:
  void* stack_addr;
public:
  int prio;
  int stackSizeLg;
  ThrH th;
  ThrQ waitq;
  Task *tsk;
  static int superthreads;
  SThread (int _prio, int _stackSizeLg) : prio(_prio), stackSizeLg(_stackSizeLg) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1583); ((int*)0)[0]=0;}};
    int stack_size;
    superthreads++;
    stack_size = 1 << stackSizeLg;
    stack_addr = stackAllocator().alloc(stack_size);
    tsk = __null;
    th.initStk = (void *)(((unsigned long)stack_addr) + stack_size);
    th.stkMin = stack_addr;
    th.cpu = thread_self();
    ThrH::spawn(&th, init, this);
  }
  ~SThread() {
  }
  static void init_threads()
  {



    ThrQS& tqs = ThrQS::tqs();
    tqs.init();
    sigset_t sigs;
    sigemptyset(&sigs);
    sigaddset(&sigs, 2);
    sigaddset(&sigs, 15);



    sigprocmask(1, &sigs, __null);

  }
  void reinit() {
    th.initProc((ThrH::proc_t)newTask, this);
    waitq.stopHereAndRunOthers();
  }
  static void init(void* _me) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1618); ((int*)0)[0]=0;}};
    SThread* me = (SThread*)_me; ;
    me->reinit();
  }
  static void newTask(SThread*);
};
class DestructionQueue {
  friend class Header;
public:
  struct qItem {
    qItem *next;
    qItem() : next(__null) {};
  };
private:
  int entered;
  qItem *head;
public:
  DestructionQueue() : entered(0),head(__null) {}
  void addToQueue(Header *td);
  ~DestructionQueue() {}
};
extern DestructionQueue destructionQueue;
class Header : public ACnt, public Viz, public DestructionQueue::qItem {
  friend class DestructionQueue;
public:
  Header(const Header&) { {if (!(0 && "Attempt to copy header")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"Attempt to copy header\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1643); ((int*)0)[0]=0;}}; }
  Header& operator= (const Header&) { {if (!(0 && "Attempt to copy header")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"Attempt to copy header\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1644); ((int*)0)[0]=0;}}; return *this; }
  Header(){}
  size_t size;
  virtual ~Header() {}
  inline static Header* halloc (size_t size) {
    ;
    Header* h = pdataAllocator->alloc(size);



    if (!h) do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Out of memory\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
    h->size = size;
    return h;
  }
  inline void* operator new (size_t size, size_t extra) {
    return halloc(size + extra);
  }
  inline static void hfree (Header* h) {
    ;



    pdataAllocator->free(h);
  }
  inline void* operator new (size_t size) {
    return halloc(size);
  }
  void* operator new (size_t size, void *mem) {
    return mem;
  }
  inline void operator delete (void* mem) {
    hfree((Header*)mem);
  }
  virtual void onZero () {
    delete this; ;
  }
};
# 1689 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class SData : public Header {
public:
  int flags;



  inline SData() : flags (0) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1696); ((int*)0)[0]=0;}};



  }
  virtual SData* clone() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1702); ((int*)0)[0]=0;}};
    return this;
  }
  virtual void onRecv() {
    ;
  }
  virtual void onZero () {
    if (!(this->flags & 32))
      destructionQueue.addToQueue(this);
    else
      hfree(this);
  }
};


class SRef : public ARef {
public:
  inline SData* operator-> () const { return (SData*) a; }
  inline SData& operator* () const {
    ;
    return *(SData*)a;
  }
  inline SData* operator= (SData *_a) {
    ;
    return (SData*) (*(ARef*)this = _a);
  }
  inline SData* operator= (const SRef& s) { return (SData*) (*(ARef*)this = s.a);}
  inline operator SData* () { return (SData*)a; }
  bool operator == (ACnt *_a) { return a==_a; }
  inline void clearRef () { (*this) = (SData*)__null; }
};
# 1762 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
extern Delay *mpiInitDelay;
extern bool mpiInitialized;
class MPIMsgStat {
private:
  MPIMsgStat(unsigned r, unsigned s) { recvCount = r; sentCount = s; }
public:
  unsigned recvCount;
  unsigned sentCount;
  MPIMsgStat() { recvCount = 0; sentCount = 0; }
  bool equal() const { return recvCount == sentCount; }
  bool operator == (const MPIMsgStat& c) const {
    return (recvCount == c.recvCount) && (sentCount == c.sentCount);
  }
  MPIMsgStat& operator += (const MPIMsgStat& c) {
    recvCount += c.recvCount;
    sentCount += c.sentCount;
    return *this;
  }
  friend MPIMsgStat operator + (const MPIMsgStat& a, const MPIMsgStat& b) {
    return MPIMsgStat(a.recvCount + b.recvCount, a.sentCount + b.sentCount);
  }
};


static entry_t traceEntry;
static int traceMode;
static int traceCount = -1;
class MPITagHandler : public Service {
  static MPITagHandler* tagHandler[5];
  static int nextTag;
  static int totalTags;
  int tag;
  MPIMsgStat msgStat;
public:
  inline int getTag() const { return tag; }
  const MPIMsgStat& getStat() const {
    return msgStat;
  };
private:
  class Request {
  private:
    SRef data;
    struct mpi_portal_request mpiRq;
  public:
    bool isFree() {
      {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1807); ((int*)0)[0]=0;}};
      return getData() == __null;
    }
    void setFree() {
      {if (!(!isFree())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!isFree()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1811); ((int*)0)[0]=0;}};
      if (data) {



 SData *d = data;
 d->flags |= 32;

 data.clearRef();
      }
    }
    void setBusy(SData *d) {
      {if (!(isFree())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isFree()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1823); ((int*)0)[0]=0;}};
      {if (!(d)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1824); ((int*)0)[0]=0;}};
      data = d;

      SData *copy = d->clone();
      data = copy;

    }
    const SData* getData() {
      return data;
    }
    ~Request() {
      {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1835); ((int*)0)[0]=0;}};
      if (!isFree()) {
        setFree();
      }
    }
    Request() : data() {}
    bool testRq() {
      struct mpi_portal_status status;
      int free;
      {if (!(this)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1844); ((int*)0)[0]=0;}};
      {if (!(!isFree())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!isFree()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1845); ((int*)0)[0]=0;}};
      { int stat = (*mpi_portal->_MPI_Test) (&mpiRq, &free, &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      if (free) setFree ();
      return free;
    }
    void sendRq(int dest, int tag, SData *d) {
      {if (!(this)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1851); ((int*)0)[0]=0;}};
      {if (!(d)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1852); ((int*)0)[0]=0;}};
      {if (!(isFree ())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isFree ()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1853); ((int*)0)[0]=0;}};
      setBusy (d);
      SData *copy = data;
      if (conf.showMsgs) do { { VizStr msgstr("[%d,%d] -> [%d]:  %s[%d]\n", myRank, tag, dest, copy->viz(), copy->size); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      {
        TaskStatistic::Holder __taskHolder(&mpiTask);
        { int stat = (*mpi_portal->_MPI_Isend) (copy, copy->size, (1), dest, tag, ((int)(-2)), &mpiRq); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
        StatisticValues& cur = StatisticValues::currentValues();
        cur.msg_count++;




        cur.msg_size += d->size;
        if (conf.enableAsync) (*mpi_portal->_DMPI_Async_ping)(dest);
       }
    }
  };
public:
  class RequestQueue {
  private:
    Request rq[0x400];
    size_t curr;
    int curRq;
  public:
    RequestQueue() : curr(0), curRq(0) {}
    Request* getFreeRq() {
      {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1880); ((int*)0)[0]=0;}};
      int i, tries;
      for (tries = 0; tries < 1000000000; tries++,sched_yield()) {
        if (curRq >= 0x400) curRq = 0;
        for (i = curRq; i < 0x400; i++)
          if (rq[i].isFree() || rq[i].testRq()) {
            ;
            curRq = i+1;
            return &rq[i];
   }
      }
      do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("No free MPI_Request (%d tries)", tries); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
      return __null;
    }
    int flushReqs (int *cnt) {
      int i;
      for (i = 0; i < 0x400; i++) {
        if (rq[i].isFree()) { continue; }
        int tries;
        int free = 0;
        bool flag;
        for (tries = 0; tries < 1000000000; tries++,sched_yield()) {
          while (dropMessage(&flag)) if (flag) {++(*cnt);}
          if (rq[i].testRq()) {
            free=1;
            break;
          }
        }
        if (!free) {
          do { { VizStr msgstr("[%d] Unable to flush request %d.\n", myRank, i); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
   return false;
        }
      }
      return true;
    }
# 1924 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  } rqq[24];
public:
  void asyncSend(SData* d, int to) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1927); ((int*)0)[0]=0;}};
    ;
    if (!totalTags) return;
    Request *rq = rqq[to].getFreeRq();
    SData *copy;







    copy = d;

    rq->sendRq (to, tag, copy);
    msgStat.sentCount++;
    rq->testRq ();
  }
# 1970 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
private:
  class MPI_Init_Delay : public Delay {
  public:
    ~MPI_Init_Delay() {
      { int stat = MPI_Init(CmdLine::mainArgc,CmdLine::mainArgv); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      traceEntry = ts::Feature::getEntry("trace");
      if (traceEntry)
        traceMode = (unsigned long) traceEntry(CmdLine::extArgc, (void *) CmdLine::extArgv);
      entry_t ckptEntry = ts::Feature::getEntry("ckpt");
      if (ckptEntry)
        ckptEntry(CmdLine::extArgc, (void *) CmdLine::extArgv);
      { int stat = (*mpi_portal->_MPI_Comm_rank)(((int)(-2)), &myRank); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      { int stat = (*mpi_portal->_MPI_Comm_size)(((int)(-2)), &realsuperSize); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      mpiInitialized = true;



      {if (!(realsuperSize<=superSize)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "realsuperSize<=superSize" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",1987); ((int*)0)[0]=0;}};
      ;
      Delay::force (mpiInitDelay);
    }
  };
public:
  MPITagHandler(const char *name,int servicePrio) : Service(name,servicePrio), tag(nextTag++) {
    if (!totalTags++) {
      (*new MPI_Init_Delay())(CmdLine::delay);
    }
    tagHandler[tag] = this; ;
  }
private:
  static bool dropMessage(bool *flag) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2001); ((int*)0)[0]=0;}};
    int avail, count;
    struct mpi_portal_status status;
    if (flag) *flag = false;
    { int stat = (*mpi_portal->_MPI_Iprobe)((-1), (-1), ((int)(-2)), &avail, &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    if (!avail) return false;
    { int stat = (*mpi_portal->_MPI_Get_count)(&status, (1), &count); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    void *d = memoryAllocator.alloc(count);
    { int stat = (*mpi_portal->_MPI_Recv)(d, count, (1), status.MPI_SOURCE, status.MPI_TAG, ((int)(-2)), &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    if (status.MPI_TAG == (5 +1)) {
      if (flag) *flag = true;
    }
    memoryAllocator.free(d);
    return true;
  }
  bool stopHandler(int *cnt) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2017); ((int*)0)[0]=0;}};
    int node;
    for (node = 0; node < superSize; node++) {
      if (node == myRank) continue;
      rqq[node].flushReqs(cnt);
    }
    return true;
  }
public:
  static void stopMPI() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2027); ((int*)0)[0]=0;}};
    {if (!(mpiInitialized)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "mpiInitialized" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2028); ((int*)0)[0]=0;}};
    int cnt = 0;
    for (int tg = 0 ; tg < totalTags; tg++) {
      tagHandler[tg]->stopHandler(&cnt);
    }
    if (myRank) {
      unsigned char d = 0xfb;
      int free = 0;
      struct mpi_portal_request mpiRq;
      cnt = 1;
      { int stat = (*mpi_portal->_MPI_Isend)(&d, 1, (1), 0, (5 +1), ((int)(-2)), &mpiRq); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      do {
 struct mpi_portal_status status;
 bool flag;
 while (dropMessage(&flag)) {if (flag) cnt--;}
 { int stat = (*mpi_portal->_MPI_Test)(&mpiRq, &free, &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
      } while (!free);
    } else {
      cnt = realsuperSize - 1 - cnt;
      do {
  bool flag;
  while (dropMessage(&flag)) {if (flag) cnt--;}
      } while (cnt);
    }
    if (myRank) {
      do {
  bool flag;
  while (dropMessage(&flag)) {if (flag) cnt--;}
      } while (cnt);
    } else {
 for (int i = 1; i < realsuperSize; i++) {
   unsigned char d = 0xfa;
   { int stat = (*mpi_portal->_MPI_Send)(&d, 1, (1), i, (5 +1), ((int)(-2))); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
 }
    }
    if (conf.enableAsync) (*mpi_portal->_DMPI_Async_done)();
    (*mpi_portal->_MPI_Barrier)(((int)(-2)));
    (*mpi_portal->_MPI_Finalize)();
    mpiInitialized = false;
  }
  virtual ~MPITagHandler() {
    if (!mpiInitialized) {
     tagHandler[tag] = __null;
     --totalTags;
     return;
    }
    if (!Service::exitError) { int stat = (*mpi_portal->_MPI_Barrier)(((int)(-2))); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    tagHandler[tag] = __null;
    if (!--totalTags) {
; { int stat = (*mpi_portal->_MPI_Finalize)(); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } }; ;
    }
  }
  virtual bool work() {
    int count = 0;
    if (traceEntry && traceMode == 2) {
      if (traceCount < 0)
        traceCount = (unsigned long) traceEntry(0, 0);
      traceCount --;
      if (traceCount >= 0)
        return false;
      count = (unsigned long) traceEntry(1, 0);
      if (count) {
        SData *d = (SData*)SData::halloc(count);
        count = (unsigned long) traceEntry(count, (void *) d);
        if (count) {
          bool flag;
          while (!dropMessage(&flag));
          msgStat.recvCount++;
          d->onRecv();
          return true;
        }
      }
      return false;
    }
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2102); ((int*)0)[0]=0;}};
    int avail;
    struct mpi_portal_status status;
    { int stat = (*mpi_portal->_MPI_Iprobe)((-1), tag, ((int)(-2)), &avail, &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    if (!avail) {
      traceCount ++;
      return false;
    }
    { int stat = (*mpi_portal->_MPI_Get_count)(&status, (1), &count); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    SData *d = (SData*)SData::halloc(count);
    {
      TaskStatistic::Holder __taskHolder(&mpiTask);
      { int stat = (*mpi_portal->_MPI_Recv)(d, count, (1), status.MPI_SOURCE, tag, ((int)(-2)), &status); if (stat != 0) { static char msg[0x1000]; int len = sizeof(msg); (*mpi_portal->_MPI_Error_string)(stat,msg,&len); do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("MPI_Error[%d != %d]: %.*s",stat, 0,len,msg); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); } };
    }
    msgStat.recvCount++;






    d->cnt = 0;
    if (traceEntry && traceMode == 1) {
      traceEntry(traceCount + 1, 0);
      traceCount = -1;
      traceEntry(count, (void *) d);
    }
; d->onRecv(); ;
    return true;
  }
};
class Cell {};
class TransportHandler : public MPITagHandler {
public:
  int cellRankSize;
  int cellStartOfs;
  int cellSize;
  int sharedSize;
  void (*onRead)(Cell*);
  void (*onWrite)(Cell*);
  void (*inPlaceCtor)(Cell*);
  void (*clearCell)(Cell*);
  static void noop(Cell*) {}
  TransportHandler(const char *name, int prio) : MPITagHandler(name,prio),
       onRead(noop), onWrite(noop), inPlaceCtor(__null), clearCell(noop) {}
};
class VZeroes {
private:
  char *start,*end;
  char *nextChunk;
private:
  static char *startMap;
  static char *endMap;
  static char *nextChunkMap;
public:
  static void checkInit() {
    if (startMap) return;
    nextChunkMap = startMap = (char*)calloc(0x800000,1);
    {if (!(startMap != __null)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "startMap != NULL" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2160); ((int*)0)[0]=0;}};
    endMap = startMap + 0x800000;
  }
  VZeroes(const char *name, size_t size) {
    checkInit();
    start = nextChunk = nextChunkMap;
    end = nextChunkMap = nextChunkMap + size;
    {if (!(nextChunkMap < endMap)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "nextChunkMap < endMap" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2167); ((int*)0)[0]=0;}}; ;
  }
  char *allocZeroes(size_t size) {
    char *result = nextChunk;
    nextChunk += size;
    {if (!(nextChunk <= end)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "nextChunk <= end" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2172); ((int*)0)[0]=0;}}; ;
    return result;
  }
  static void* getAddress(int offset) { return startMap+offset; }
  static int getOffset(const void* addr) { return ((char*)addr)-startMap; }
};
static inline int lg(int qty) {
  if (qty <= 1) return 0;
  qty -= 1;
  int l=1;
  while(qty >>= 1) l++;
  return l;
}

template <typename Chunk>

class CachedChunks {
private:
  Chunk* cache[32];
  int inUse;
public:
  CachedChunks() : inUse(0) { memset(cache,0,sizeof(cache)); }
  void finalize() {
    if (inUse) do { { VizStr msgstr("rank%d: %d supercells are locked\n", myRank, inUse); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
  }
  int used() const { return inUse; }
private:
  inline Chunk* pop(Chunk** p) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2200); ((int*)0)[0]=0;}};
    Chunk *c = *p;
    if (!c) c = fillUp(p);
    *p = (Chunk*)c->getClink(); ;
    c->setClink((Chunk*)((void*)-1));
    return c;
  }
  inline void push(Chunk** p, Chunk *c) {
    c->setClink(*p);
    *p = c;
  }
  Chunk* fillUp(Chunk** p) {
    if ( p+1 >= cache+32 ) do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Out of supermemory\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
    Chunk *c = pop(p+1);
    int lg = p-cache;
    Chunk *c1 = c + (1<<lg);
    c->chunkSetLg(lg); c1->chunkSetLg(lg);
    push(p,c1); push(p,c);
    return c;
  }
public:
  inline Chunk* allocChunk(int qty) {
    ;
    ;
    {if (!(qty > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "qty > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2224); ((int*)0)[0]=0;}};
    inUse += qty;
    Chunk* c = pop(cache+lg(qty));
    return c;
  }
  inline void freeChunk(Chunk* c, int qty) {
    ;
    {if (!(qty > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "qty > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2231); ((int*)0)[0]=0;}};
    inUse -= qty;
    push(cache+lg(qty),c); ;
  }
  void flushAllChunks() {
    ;
    Chunk** p;
    for (p=cache; p < cache+32; p++) while (*p) Chunk::chunkBaseFree(pop(p));
  }
  void initCollect() {
    int _inUse = inUse;
    flushAllChunks();
    Chunk::chunkInit(this);
    inUse = _inUse;
  }
};
class MasterSCell {
private:
  unsigned mstRq:1;
  unsigned mstDone:1;
  unsigned mstReady:1;
public:
  inline void mstInit () { mstDone = 0; mstReady = 0; mstRq = 0; }
  inline void mstSetDone () { mstDone = 1; mstReady = 0; mstRq = 0; }
  inline void mstSetReady () { mstReady = 1; {if (!(!mstRq)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!mstRq" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2255); ((int*)0)[0]=0;}}; }
  inline void mstSetRq () { {if (!(!mstReady)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!mstReady" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2256); ((int*)0)[0]=0;}}; mstRq = 1; }
  inline bool mstIsDone () const { return mstDone; }
  inline bool mstIsReady () const { return mstReady; }
  inline bool mstIsRq () const { return mstRq; }
};
class SlaveSCell {
public:
  unsigned slvRq:1;
  unsigned slvReady:1;
public:
  inline void slvInit () { slvRq = slvReady = 0; }
  inline void slvSetReady () { slvRq = 0; slvReady = 1; }
  inline void slvSetRq () { {if (!(!slvReady)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!slvReady" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2268); ((int*)0)[0]=0;}}; slvRq = 1; }
  inline bool slvIsReady () const { return slvReady; }
  inline bool slvIsRq () const { return slvRq; }
};
class ChunkCell : public Cell {
public:
};
template <TransportHandler& handler> class Data;
template <TransportHandler& handler> class SPtr;
template <TransportHandler& handler>
class SCell : public ChunkCell {
private:
  SCell(const SCell<handler>&) { {if (!(0 && "Attempt to copy supercell")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"Attempt to copy supercell\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2280); ((int*)0)[0]=0;}}; }
  SCell<handler>& operator= (const SCell<handler>&) { {if (!(0 && "Attempt to copy supercell")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"Attempt to copy supercell\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2281); ((int*)0)[0]=0;}}; return *this; }
protected:
  long long seqNo;
  MasterSCell mstFlags;
  SlaveSCell slvFlags;
private:
  SRef ref;
private:
  SCell<handler> *clink;
public:
  inline void setClink(SCell<handler>* l) { clink = l; }
  inline SCell<handler>* getClink() const { return (SCell<handler>*)clink; }
  unsigned ctDone:1;
  inline SCell() {
    if (isShared() || master() == myRank) mstFlags.mstInit();
    slvFlags.slvInit();
    ctDone = 1;
    if (!isShared() && master() == myRank) seqNo++;
    {if (!(cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2299); ((int*)0)[0]=0;}};
  }
  virtual ~SCell() {
    if (master() == myRank) finalizeMaster();
    ctDone = 0;
  }
  inline long long getSeqNo () const { return seqNo; }

  inline int offset() const { return VZeroes::getOffset(this); }
  inline int oindex() const {
    return (offset()-handler.cellStartOfs) % handler.cellRankSize;
  }
  inline int master() const {
    {if (!(!isShared())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!isShared()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2312); ((int*)0)[0]=0;}};
    return (offset()-handler.cellStartOfs) / handler.cellRankSize;
  }
  inline bool isShared() const {
    bool res = offset()-handler.cellStartOfs >= handler.cellRankSize*superSize;
    return res;
  }
  inline bool cellIsOk() const {
    if (!this) return false;
    bool ok = ctDone && ( offset() >= 0x1000 && offset() < handler.cellStartOfs + handler.cellRankSize*superSize+handler.sharedSize);
    if (!ok) {
      fprintf (stderr," Wrong cell %p clink %p offset %x bound %x \n", this, clink, offset(), handler.cellStartOfs + handler.cellRankSize*superSize+handler.sharedSize);
    }
    return ok;
  }
  static inline SCell<handler>& checkInit(SCell<handler>& c) {
    if (!c.ctDone) handler.inPlaceCtor(&c);
    return c;
  }
  static inline void finalizeCell(SCell<handler>& c) {
    if (c.ctDone) {
      {if (!(c.cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "c.cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2333); ((int*)0)[0]=0;}};
      c.ref.clearRef();
      handler.clearCell(&c);
      c.ctDone = 0;
    }
  }
  static inline SCell<handler>& cellAt(int offs) {
    return checkInit(*(SCell<handler> *)(VZeroes::getAddress(offs)));
  }
  static inline SCell<handler>& cellAtNoInit(int offs) {
    return *(SCell<handler> *)(VZeroes::getAddress(offs));
  }
  static inline SCell<handler>* checkInitSeqNo(SCell<handler>& c, long long sn) {
# 2360 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    ;
    if (!c.ctDone) {
      checkInit(c);
      {if (!(c.seqNo <= sn)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "c.seqNo <= sn" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2363); ((int*)0)[0]=0;}};
      c.seqNo = sn;
    } else {
      if (c.seqNo > sn) {
        do { { VizStr msgstr("REinit cell [%d:%x:%lld] (%lld) by access\n", c.master(), c.oindex(), sn, c.getSeqNo()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      }
      {if (!(c.seqNo <= sn)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "c.seqNo <= sn" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2369); ((int*)0)[0]=0;}};
      if (c.seqNo < sn) {
 finalizeCell(c);
 checkInit(c);
 c.seqNo = sn;
      }
    }

    return &c;
  }
  static inline SCell<handler>* cellAtSeqNo(int offs, long long sn) {
    return checkInitSeqNo(*(SCell<handler> *)(VZeroes::getAddress(offs)), sn);
  }


  inline int mirror(int rank) const {
    {if (!(!isShared())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!isShared()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2385); ((int*)0)[0]=0;}};
    ;
    return handler.cellStartOfs + rank*handler.cellRankSize + oindex();
  }

  inline MasterSCell& masterImage (int rank) const {
    {if (!(master() == myRank)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "master() == myRank" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2391); ((int*)0)[0]=0;}};



    return cellAt(mirror(rank)).mstFlags;

  }
  virtual void dumpLeakCell() { }
  static inline void checkLeakCell(SCell<handler>& c) {
    if (!c.ctDone) return;
    c.dumpLeakCell();
  }
  inline SPtr<handler> ptr() const {
    SPtr<handler> result(offset(),getSeqNo());
    return result;
  }

  inline Data<handler>& data() {
    return *(Data<handler> *)& * ref;
  }
  inline Data<handler>* operator = (Data<handler>* d) {
    return (Data<handler>*)(ref = d);
  }
  inline operator Data<handler>* () {
    return &data();
  }

private:

  void finalizeMaster() {
    int i;
    for (i = 0; i < realsuperSize; i++) {
      MasterSCell& c = masterImage(i);
      if (c.mstIsDone()) handler.asyncSend(new Data<handler>(ptr(), &SCell<handler>::onSlvFinalize, "finalize", 0), i);
      c.mstInit();
    }
    ref.clearRef();
  }
  void onSlvFinalize(Data<handler>& d) {
    {if (!(cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2430); ((int*)0)[0]=0;}};
    finalizeCell(*this);
  };
public:

  static void chunkBaseFree(SCell<handler>*) {
    ;
  }
  static void chunkInit(void *_cc) {
    ;
    CachedChunks< SCell<handler> >* cc = (CachedChunks< SCell<handler> >*) _cc;
    ;
    int ofs = 0;
    size_t qty = handler.cellRankSize/handler.cellSize;
    while (qty) {
      size_t curr = 1 << (lg(qty + 1) - 1);
      cc->freeChunk((SCell<handler>*)(VZeroes::getAddress(handler.cellStartOfs + handler.cellRankSize * myRank + (ofs * handler.cellSize))), curr);
      ofs += curr;
      qty -= curr;
    }
  }
  void chunkSetLg(int) { }
};

template <TransportHandler& handler>
class SPtr {
public:
  int cellOffset;
  long long seqNo;
public:
  inline SPtr() : cellOffset(0), seqNo(0) {}
  inline SPtr(int offs, long long seq) : cellOffset(offs), seqNo(seq) {}
  inline SPtr(const SPtr& s) : cellOffset(s.cellOffset), seqNo(s.seqNo) {}
  inline SPtr<handler>& operator = (const SPtr<handler>& s) {
    cellOffset = s.cellOffset;
    seqNo = s.seqNo;
    return *this;
  }
  inline SPtr<handler>& operator = (const SCell<handler>* p) {
    if (p) {
      *this = p->ptr();
    } else {
      cellOffset = 0;
      seqNo = 0;
    }
    return *this;
  }
  inline bool operator == (const SPtr<handler>& s) const {
    if (cellOffset == s.cellOffset) {
      {if (!(seqNo == s.seqNo)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "seqNo == s.seqNo" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2479); ((int*)0)[0]=0;}};
      return true;
    } else {
      return false;
    }
  }
  inline bool isNull () const { return cellOffset == 0; }
  inline bool notNull () const { return cellOffset != 0; }
  inline SCell<handler>* getObjPtr() const {
    if (isNull()) return __null;
    return SCell<handler>::cellAtSeqNo(cellOffset,seqNo);
  }
  inline SCell<handler>* getObjPtrNoUpd() const {
    if (isNull()) return __null;



    return &SCell<handler>::cellAt(cellOffset);

  }
};
template <TransportHandler& handler>
class Data : public SData {
public:
  SPtr<handler> ptr;
  typedef void (SCell<handler>::*OnRecvMethod)(Data<handler>&);
  OnRecvMethod method;
  int srcRank;
  Data() : ptr(), method(__null), srcRank(myRank) {}
  Data(const SPtr<handler>& _ptr, OnRecvMethod _method, const char* _vid, int _flags = 0) :
    ptr(_ptr), method(_method), srcRank(myRank) { vid = _vid; flags |= _flags; }
  inline Data(const Data& d) {
    ptr = d.ptr;
    method = d.method;
    srcRank = d.srcRank;
  }
  virtual void onRecv() {
    SRef forCollect;
    forCollect = this;
# 2543 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    SCell<handler> *c = ptr.getObjPtrNoUpd();
    if (c->getSeqNo() > ptr.seqNo) {
      do { { VizStr msgstr("Cell [%d:%x:%lld] got request on %lld (%s [%d])\n", c->master(), c->oindex(), c->getSeqNo(), ptr.seqNo, viz(), size); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);


      return;
    }
    c = ptr.getObjPtr();

; (c->*method)(*this); ;
  }
};
template <TransportHandler& handler>
class DataCell : public SCell<handler> {
private:
  void onMstRead(Data<handler> &d) {
    MasterSCell& slv = masterImage(d.srcRank);
    if (!slv.mstIsReady()) slv.mstSetRq();
    else sendToSlave(d.srcRank);
    handler.onRead(this);
  }
  inline void masterUpdateData() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2565); ((int*)0)[0]=0;}};
    int i;
    for (i = 0; i < realsuperSize; i++) {
      MasterSCell& c = this->masterImage(i);
      ;
      if (c.mstIsRq()) sendToSlave(i);
      else c.mstSetReady();
    }
  }
  void onMstWrite(Data<handler>& d) {
    if (&this->data() != &d) {
      *(SCell<handler>*)this = &d;
    }
    ;
    ;
    if (d.srcRank != myRank) {
      MasterSCell& slv = masterImage(d.srcRank);
      slv.mstSetDone();
    }
    masterUpdateData();
    handler.onWrite(this);
  }
  inline void sendToSlave(int slvRank) {
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2588); ((int*)0)[0]=0;}}; ;
    SRef collect;
    Data<handler> *d = &this->data();







    d->method=(typename Data<handler>::OnRecvMethod)&DataCell<handler>::onSlvWrite;
    d->ptr = this->ptr();



    handler.asyncSend(d,slvRank);
    MasterSCell& slv = this->masterImage(slvRank);
    slv.mstSetDone();
  }
private:
  void onSlvWrite(Data<handler>& d) {
    ;
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2610); ((int*)0)[0]=0;}};
    this->slvFlags.slvSetReady();
; *(SCell<handler>*)this=&d; ;

    this->seqNo = d.ptr.seqNo;

; handler.onWrite(this);;
  }
  inline void sendToMaster() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2619); ((int*)0)[0]=0;}};
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2620); ((int*)0)[0]=0;}}; ;
    SRef collect;
    Data<handler> *d = &this->data();







    d->method=(typename Data<handler>::OnRecvMethod)&DataCell<handler>::onMstWrite;
    d->ptr = this->ptr();



    handler.asyncSend(d,this->master());
    this->slvFlags.slvSetReady();
  }
public:
  void write() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2640); ((int*)0)[0]=0;}};
    {if (!(!this->isShared())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!this->isShared()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2641); ((int*)0)[0]=0;}};
    ;
    this->data().srcRank = myRank;
    if (this->master() == myRank) masterUpdateData(); else sendToMaster();

     handler.onWrite(this);

  }
  void read() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2650); ((int*)0)[0]=0;}};
    {if (!(!this->isShared())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!this->isShared()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2651); ((int*)0)[0]=0;}};
    if (this->master() == myRank) { handler.onRead(this); return; }
    {if (!(!(this->slvFlags.slvRq && this->slvFlags.slvReady))) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!(this->slvFlags.slvRq && this->slvFlags.slvReady)" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2653); ((int*)0)[0]=0;}};
    if (this->slvFlags.slvRq) return;
    this->slvFlags.slvReady = 0;
    ;
    handler.asyncSend(new Data<handler>(this->ptr(),(typename Data<handler>::OnRecvMethod)&DataCell<handler>::onMstRead,"readRq"), this->master());
    this->slvFlags.slvRq = 1;
  }




};
template <TransportHandler& handler>
class StaticCell : public SCell<handler> {
private:
  void onMstRead(Data<handler> &d) {
    MasterSCell& slv = this->masterImage(d.srcRank);
    if (!slv.mstIsReady()) slv.mstSetRq();
    else sendToSlave(d.srcRank);
    handler.onRead(this);
  }
  inline void masterUpdateData() {
    int i;
    for (i = 0; i < realsuperSize; i++) {
      MasterSCell& c = this->masterImage(i);
      ;
      if (c.mstIsRq()) sendToSlave(i);
      else c.mstSetReady();
    }
  }
  void onMstWrite(Data<handler>& d) {
    if (&this->data() != &d) {
      *(SCell<handler>*)this = &d;
    }
    ;
    ;
    if (d.srcRank != myRank) {
      MasterSCell& slv = this->masterImage(d.srcRank);
      slv.mstSetDone();
    }
    masterUpdateData();
    handler.onWrite(this);
  }
  inline void sendToSlave(int slvRank) {
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2697); ((int*)0)[0]=0;}}; ;
    this->data().method=(typename Data<handler>::OnRecvMethod)&StaticCell<handler>::onSlvWrite;
    this->data().ptr=this->ptr();
    handler.asyncSend(&this->data(),slvRank);
    MasterSCell& slv = this->masterImage(slvRank);
    slv.mstSetDone();
  }
private:
  void onSlvWrite(Data<handler> &d) {
    ;
    this->slvFlags.slvSetReady();
; *(SCell<handler>*)this = &d; ;
    this->seqNo = d.ptr.seqNo;
; handler.onWrite(this);;
  }
  inline void sendToMaster() {
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2713); ((int*)0)[0]=0;}}; ;
    this->data().method=(typename Data<handler>::OnRecvMethod)&StaticCell<handler>::onMstWrite;
    this->data().ptr=this->ptr();
    handler.asyncSend(&this->data(),this->master());
    this->slvFlags.slvSetReady();
  }
  void writeToAll() {
    {if (!(this->isShared())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->isShared()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2720); ((int*)0)[0]=0;}};
    this->data().method = (typename Data<handler>::OnRecvMethod)&StaticCell<handler>::onSlvWrite;
    this->data().ptr = this->ptr();
    int i;
    for (i = 0; i < realsuperSize; i++) {
      if (i == myRank) continue;
      handler.asyncSend(&this->data(),i);
    }
  }
public:
  inline Data<handler>* operator = (Data<handler>* d) {
    return *((SCell<handler>*)this) = d;
  }
  void write() {
    this->data().srcRank = myRank;
    if (this->isShared()) { writeToAll(); return; }
    if (1 < this->getSeqNo()) {
      do { { VizStr msgstr("INFO: attempt to overwrite with seqNo %llx less than current %llx\n",1,this->getSeqNo()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      ((int*)0)[0] = 0;
      return;
    }
    if (this->master() == myRank) masterUpdateData(); else sendToMaster();
  }
  void read() {
    if (this->isShared() || this->master() == myRank) { {if (!(this->getSeqNo() == 1)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->getSeqNo() == 1" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2744); ((int*)0)[0]=0;}}; handler.onRead(this); return; }
    {if (!(!(this->slvFlags.slvRq && this->slvFlags.slvReady))) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!(this->slvFlags.slvRq && this->slvFlags.slvReady)" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2745); ((int*)0)[0]=0;}};
    if (this->slvFlags.slvRq) return;
    this->slvFlags.slvReady = 0;
    ;
    handler.asyncSend(new Data<handler>(SPtr<handler>(this->offset(),1),(typename Data<handler>::OnRecvMethod)&StaticCell<handler>::onMstRead,"readRq"), this->master());
    this->slvFlags.slvRq = 1;
  }
};
template <TransportHandler& handler>
class SharedCell : public SCell<handler> {
private:
  void onSlvWrite(Data<handler> &d) {
    ;
; *(SCell<handler>*)this = &d; ;
; handler.onWrite(this);;
  }
public:
  void writeToAll() {
    this->data().method = (typename Data<handler>::OnRecvMethod)&SharedCell<handler>::onSlvWrite;
    this->data().ptr = this->ptr();
    int i;
    for (i = 0; i < realsuperSize; i++) {
      if (i == myRank) continue;
      handler.asyncSend(&this->data(),i);
    }
  }
  inline Data<handler>* operator = (Data<handler>* d) {
    return *((SCell<handler>*)this) = d;
  }
};
template <typename Cell, TransportHandler& handler, int cellsPerNode>
class DynamicSegment : public CachedChunks<Cell>, public VZeroes {
private:
  class SSegDelay : public Delay {
  private:
    CachedChunks<Cell> *data;
  public:
    SSegDelay (CachedChunks<Cell> *_data) : data(_data) {}
    ~SSegDelay() {
      data->initCollect();
    }
  };
  Cell *ns;
public:
  DynamicSegment() : VZeroes(__PRETTY_FUNCTION__,sizeof(Cell)*(cellsPerNode*superSize) + 0x1000) {
    ns = (Cell*) (allocZeroes(sizeof(Cell)*(cellsPerNode*superSize) + 0x1000) + 0x1000);
    handler.cellStartOfs = VZeroes::getOffset(ns);
    handler.cellSize = sizeof(Cell);
    handler.cellRankSize = sizeof(Cell)*cellsPerNode;
    handler.sharedSize = 0;
    (*new SSegDelay(this))(mpiInitDelay);
  }
  void dumpLeakedCells() {
    for (int i = 0; i < cellsPerNode * realsuperSize; i++) {
      Cell::checkLeakCell(ns[i]);
    }
  }
};
template <typename cell, TransportHandler& handler, int cellsPerNode, int sharedCells=0>
class StaticSegment : public VZeroes {
private:
  class SSegDelay : public Delay {
  private:
    cell *ns;
  public:
    SSegDelay (cell *_ns) : ns(_ns) {}
    ~SSegDelay() {
      for (int i=0; i < cellsPerNode*superSize+sharedCells; i++) {
        new (ns+i) cell;
      }
    }
  };
  cell *ns;
public:
  StaticSegment() : VZeroes(__PRETTY_FUNCTION__,sizeof(cell)*(cellsPerNode*superSize+sharedCells) + 0x1000) {
    ns = (cell*) (allocZeroes(sizeof(cell)*(cellsPerNode*superSize+sharedCells) + 0x1000) + 0x1000);
    handler.cellStartOfs = VZeroes::getOffset(ns);
    handler.cellSize = sizeof(cell);
    handler.cellRankSize = sizeof(cell)*cellsPerNode;
    handler.sharedSize = sizeof(cell)*sharedCells;
    (*new SSegDelay(ns))(mpiInitDelay);
  }
  cell& operator[] (int i) {
   ;
    return (ns [i]);
  }
  cell& sharedCell (int i) {
    ;
    {if (!(i >= 0 && i < sharedCells)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "i >= 0 && i < sharedCells" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2833); ((int*)0)[0]=0;}};
    return ns [i+cellsPerNode*superSize];
  }
};


extern TransportHandler controlHandler, dataHandler, drcHandler;
template <typename type>
class MData : public Data<dataHandler> {
public:
  MData() {}
  MData(const MData& m) : Data<dataHandler>(m) {}
};
template <typename type>
class MControlData : public Data<controlHandler> {
public:
  type val;
  inline type& operator ()() { return val; }
  inline MControlData() {}
  inline MControlData(const MControlData& m) : Data<controlHandler>(m), val(m.val) {
    ;
    {if (!(m.size == this->size)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m.size == this->size" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2854); ((int*)0)[0]=0;}};
  }
  inline MControlData<type>& operator= (const MControlData<type>& m) {
    ;
    {if (!(m.size == this->size)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m.size == this->size" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2858); ((int*)0)[0]=0;}};
; this->val = m.val; ;
    return *this;
  }
  virtual SData* clone () {
    SData* result = (SData*) new (SData::halloc(this->size)) MControlData<type>(*this);
    return result;
  }
};


class DRCObj : public DataCell<dataHandler>, public ThrQ {
public:
  int lcnt;
  long long taken, we;
  unsigned takeRqSent : 1;
  static int inDRCwaiting;
  short sig;
  inline DRCObj() : lcnt(0), taken(0), we(0), takeRqSent(0), sig(17) {



  }
  inline bool drcObjOk() { return sig == 17; }
  inline void putWEE(signed char &wee) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2883); ((int*)0)[0]=0;}};
    {if (!(drcObjOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "drcObjOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2884); ((int*)0)[0]=0;}};
    {if (!(wee > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "wee > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2885); ((int*)0)[0]=0;}}; ;
    we += 1LL << wee;
    wee = -1;
    lcnt++;
  }
  static inline char we2wee (long long we) {
    {if (!(we >= 2)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "we >= 2" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2891); ((int*)0)[0]=0;}};
    if (we > (1LL << 31)) return 31;
    if (we > (1LL << 16)) return 16;
    if (we > (1LL << 8)) return 8;
    if (we > (1LL << 4)) return 4;
    if (we > (1LL << 2)) return 2;
    return 1;
  }
  inline signed char getWEE() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2900); ((int*)0)[0]=0;}};
    {if (!(drcObjOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "drcObjOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2901); ((int*)0)[0]=0;}};






    if (we < 4) { takeWE(); {if (!(we > 4)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "we > 4" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2908); ((int*)0)[0]=0;}}; }
    signed char wee = we2wee(we);
    we -= 1LL << wee;
    {if (!(wee > 0 && we >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "wee > 0 && we >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2911); ((int*)0)[0]=0;}};
    return wee;
  }
  inline void take(long long &_we) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2915); ((int*)0)[0]=0;}};
    {if (!(drcObjOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "drcObjOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2916); ((int*)0)[0]=0;}};
    taken -= _we;
    _we = 1LL << 31;
    taken += _we;
  }
  inline void retrieve(long long &_we) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2922); ((int*)0)[0]=0;}};
    {if (!(drcObjOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "drcObjOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2923); ((int*)0)[0]=0;}};
    taken -= _we;
    {if (!(taken >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "taken >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2925); ((int*)0)[0]=0;}};
    _we = 0;
    if (taken == we && lcnt == 0) delete this;
  }
  inline void onLZero() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2930); ((int*)0)[0]=0;}};



      retrieveWE();
  }
  virtual void takeWE() = 0;
  virtual void retrieveWE() = 0;
  class DRCData : public Data<dataHandler> {
  public:
    long long we;
    DRCData (const SPtr<dataHandler>& _p, OnRecvMethod _method, long long _we, const char *vid) :
      Data<dataHandler>(_p, _method, vid), we(_we) {}
  };
  void onTake(Data<dataHandler> &_d) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2945); ((int*)0)[0]=0;}};
    DRCData& d = (DRCData&)_d;
    take(d.we);
    d.vid = "takeReply";
    d.method = (Data<dataHandler>::OnRecvMethod)&ts::DRCObj::onTakeReply;
    int srcRank = d.srcRank;
    d.srcRank = myRank;






          dataHandler

                     .asyncSend(&d, srcRank); ;
  }
  void onTakeReply(Data<dataHandler> &_d) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2963); ((int*)0)[0]=0;}};
    DRCData& d = (DRCData&)_d;
    we += d.we;
    takeRqSent = 0;
    contTasks();
  }
  void onRetrieve(Data<dataHandler> &_d) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2970); ((int*)0)[0]=0;}};
    DRCData& d = (DRCData&)_d;
    {if (!(d.we > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.we > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",2972); ((int*)0)[0]=0;}};
    retrieve(d.we);
  }
  virtual ~DRCObj() {




    sig = 0;
  }
# 3001 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
};
class DRCRef {
public:
  signed char wee;
  inline void lighten() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3006); ((int*)0)[0]=0;}};
    if (wee > 0) getObj().putWEE(wee);
  }
  inline void ctor(DRCObj* obj = __null) { wee = obj ? obj->getWEE() : 0; }
  signed char getWEE() {
    lighten();
    return wee ? getObj().getWEE() : 0;
  }
  inline void dtor() {
    ;
    lighten();
    {if (!(!wee || getObj().lcnt > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!wee || getObj().lcnt > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3017); ((int*)0)[0]=0;}};
    if (wee && !--getObj().lcnt) getObj().onLZero();
  }




  virtual DRCObj& getObj() = 0;
};







template <typename type>
class MObj;
template <typename type>
class MRef : protected DRCRef, public SPtr<dataHandler> {
private:
  int pflags;
public:
  inline MRef(MObj<type>* mo = __null) { ctor(mo); }
  inline MRef(const MRef<type>& mr) {
    ;
    ctor(mr.getMObjPtr());
  }
  inline MRef& operator= (MObj<type>* mo) {
    ;



    MRef<type> holder(getMObjPtr());

    if (getMObjPtr() != mo) { dtor(); ctor(mo); }
    return *this;
  }
  inline MObj<type>* operator= (const MRef<type>& mr) {
    ;
    ;




    *this = mr.getMObjPtr();

    return getMObjPtr();
  }
  inline void lighten() {
    DRCRef::lighten();
  }
# 3080 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  inline MObj<type>* getMObjPtr() const {




    return (MObj<type>*)getObjPtr();
  }

  inline MObj<type>& operator* () const ;

  virtual DRCObj& getObj();
  virtual ~MRef() {
    ;
    DRCRef::dtor();
    SPtr<dataHandler>::operator = (__null);
  }
  void ctor(MObj<type>* mo);

  void dtor();

};
struct Resource {
  int prio;
  int mflops;
  int mbytes;
  int bogomips;
  int wantedTaskMFlops;
  Resource() : prio(0),mflops(0),mbytes(0),bogomips(0),wantedTaskMFlops(0) {}
  bool operator== (Resource& r) { ;
    return prio==r.prio && mflops==r.mflops && bogomips==r.bogomips &&
      mbytes==r.mbytes && wantedTaskMFlops==r.wantedTaskMFlops;
  }
  Resource& operator= (const Resource& r) {
    prio = r.prio; mflops = r.mflops; bogomips = r.bogomips;
    mbytes = r.mbytes; wantedTaskMFlops = r.wantedTaskMFlops;
    return *this;
  }
  Resource& operator += (const Resource &r) {
    prio += r.prio; mflops += r.mflops; bogomips += r.bogomips;
    mbytes += r.mbytes;
    return *this;
  }
  const char* viz() {
    static char buf[0x100];
    snprintf(buf, sizeof(buf)-1, "[%'.1fGf,%dBM,%'.2fGiB]",
      mflops/1000., bogomips, mbytes/1024.);
    return buf;
  }
};

class FreeResource : public Resource {
public:
  static double doFlops (long long n) {
    float x=0.,x1=0.,x2=0.,x3=0.,x4=0.;
    while ((n-=16) > 0) x = x + x1 * x2 + x3 * x4;
    return x;
  }
  static long usecFlops(int n) {
    double startTime = wTime(); doFlops(n); double endTime = wTime();
    return (long)(1000000.*(endTime - startTime));
  }
  FreeResource() {
    prio = tc().nodePrio;
    long long flop = 10000000;
    int flopTime = usecFlops(flop);
    flop *= 100000; flop /= flopTime;
    (*mpi_portal->_MPI_Barrier)(((int)(-2)));
    mflops = flop/usecFlops(flop);

    const char *bogoStr = fileInfo("/proc/cpuinfo","bogomips",": ","\n");
    bogomips = bogoStr ? atoi(bogoStr) : 1000;






    mbytes = ((long long)sysconf(_SC_PHYS_PAGES)*(long long)sysconf(_SC_PAGESIZE))/(1024*1024);
  }
};
int getCurrentMFlops();
class TaskResource : public Resource {
public:
  int atRank;
  int stackSizeLg;
  bool do_C_call;
  TaskResource() : atRank(tc().atRank), stackSizeLg(tc().stackSizeLg), do_C_call(false) {
    {if (!(atRank >= -1 && atRank < realsuperSize)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "atRank >= -1 && atRank < realsuperSize" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3167); ((int*)0)[0]=0;}};
    prio = tc().prio;
    mflops = getCurrentMFlops()+1;
    if (mflops >= -1) {
      mflops = -1;
      if (conf.autoCcall) {
 do_C_call = true;
 stackSizeLg = 17;
      }
    }
    mbytes = tc().mbytes;
  };
};
class TaskCtxt {
  static long lastTaskClassId;
  static const int max_name_len = 30;
  char name_[max_name_len+1];
public:
  long taskClassId;
  TaskCtxt(char *name) : taskClassId(++lastTaskClassId) {
    strncpy(name_, name, max_name_len);
    name_[max_name_len] = '\0';
  }
  char *name() {
    return name_;
  }
};



extern ThreadLocal<Task> userRootTask;
class Task : public MControlData<TaskResource>, public Ring, public TaskStatistic {
  static long lowNextTaskId;
  static inline long long newTaskId() {
    ;
    return (long long)++lowNextTaskId + (((long long)myRank) << 32);
  }
public:
  long long taskId;
  bool packed;
  bool reallyFinished;
private:
  static ThreadLocal<Task*> _current;
  char label[0x40];
public:
  inline Task() : TaskStatistic(0, 0) { }
  static inline Task* getCurrent() {
    return _current();
   }
  inline bool isSystem() {
    return (taskId<0);
  }
  inline bool isUser() {
    return (taskId>0);
  }
  inline bool isSystemRoot() {
    return (taskId==-4);
  }
  inline virtual SData* clone() { return this; }
  static inline bool inUserTask() {
    Task *t = getCurrent();
    return t ? t->isUser() : false;
  }
  static inline void setCurrent(Task* t) {
    {if (!(t)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "t" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3231); ((int*)0)[0]=0;}};
    Task*& current = _current();
    {if (!(current)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "current" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3233); ((int*)0)[0]=0;}};
    if (t == current)
      return;
     current->switchStatistic(t);
     current = t;
  }
  static inline void enterCurrent(Task* t) {
    {if (!(t)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "t" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3240); ((int*)0)[0]=0;}};
    Task* &current = _current();
    if (!t->isSystemRoot()) {if (!(current)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "current" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3242); ((int*)0)[0]=0;}};
    if (t == current)
      return;
    t->enter(0);
    current = t;
  }
  Task *parent;
  SThread* sth;
  static size_t (*get_extra)(void);
  static void (*after_ctor)(Task*);
  static size_t get_extra_default(void) {return 0;}
  static void after_ctor_default(Task*) {return;}
  virtual TaskCtxt& context(){
    {if (!(0 && "ERROR: Task::context() called for pseudo-task\n")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"ERROR: Task::context() called for pseudo-task\\n\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3255); ((int*)0)[0]=0;}};
    return *(TaskCtxt*)0;
  }
  void setLabel(const char *format, ...) {
    va_list args;
    __builtin_va_start(args,format);
    vsnprintf(label,sizeof(label)-1,format,args);
    label[sizeof(label)-1] = 0;
    __builtin_va_end(args);
  }
  const char* getLabel() const { return label; }
  inline Task(long long taskId_, TaskStatistic* upStat_) :
    TaskStatistic(upStat_, taskId_),
    taskId((taskId_) ? taskId_ : newTaskId()),
    packed(false), reallyFinished(false), parent(getCurrent())
  {
    label[0] = 0;
    if (isUser()) setCurrent(this); ;
  }
  inline void activate() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3275); ((int*)0)[0]=0;}};
    {if (!(isUser())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isUser()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3276); ((int*)0)[0]=0;}};
    upStat = &userRootTask();
    TaskResource& tskres = (*this)();
    sth = threadAllocator().alloc(tskres.prio, tskres.stackSizeLg);
    sth->tsk = this;
    sth->waitq.contTasks();
  }
  virtual void packState() {
    {if (!(!packed)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!packed" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3284); ((int*)0)[0]=0;}};
    packed = true;
  }
  virtual void unpackState() {
    {if (!(packed)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "packed" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3288); ((int*)0)[0]=0;}};
    packed = false;
    {if (!(isUser())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isUser()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3290); ((int*)0)[0]=0;}};
  }



  virtual void onRecv();
  virtual void work() {
    {if (!(0 && "ERROR: Task::work() called for pseudo-task\n")) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0 && \"ERROR: Task::work() called for pseudo-task\\n\"" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3297); ((int*)0)[0]=0;}};
  }
  virtual ~Task() {



  }
};
extern ThreadLocal<Task> rootTask;
extern ThreadLocal<Task> idleTask;
extern ThreadLocal<Task> userRootTask;
extern ThreadLocal<Task> systemRootTask;
extern Task schedTask;
extern Task mpiTask;
class TaskPrioQueue {
public:
  Ring tasks[3];
  int count;
  TaskPrioQueue() : count(0) {}
  void put(Task& t, bool fromExport) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3317); ((int*)0)[0]=0;}};
    fromExport ? tasks[t().prio].pushBack(t) : tasks[t().prio].pushFront(t);
    count++;
  }
  Task *get(bool forExport) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3322); ((int*)0)[0]=0;}};
    int i;
    for (i=0; i<3; i++) {
      if (!tasks[i].ringEmpty()) {
 return (Task*)(forExport ? tasks[i].getBack() : tasks[i].getFront());
      }
    }
    return __null;
  }
  Task* pop(bool forExport) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3332); ((int*)0)[0]=0;}};
    Task *result = get(forExport);
    if (result) { count--; result->remove(); }
    return result;
  }
  void remove(Task *t) {
    {if (!(count > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "count > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3338); ((int*)0)[0]=0;}};
    count--;
    t->remove();
  }
  void clear() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3343); ((int*)0)[0]=0;}};
    ;
    for (int i = 0; i < 3; i++) {
      while (!tasks[i].ringEmpty()) {
        delete (Task *)tasks[i].popFront();
        count--;
      }
    }
  }
};
extern TaskPrioQueue tq;
extern TaskPrioQueue ptq;
class MThread : public Task {
public:
  MThread();
  bool isRunning;
  bool finishCondition();
  virtual void start() {
    if (finishCondition()) throw new FinalizeException();
  }
  virtual void stop() {
  }
  void run() {
    ;
    if (!isRunning) { ;
     ptq.put(*this,false);
     isRunning = true;
    }
  }
  virtual void work() = 0;
  virtual ~MThread() { ;
  }
};
# 3384 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
template <typename type>
class MObj : public DRCObj {
public:
  long long owner;
protected:
  inline bool isOwned () const {
    return Task::inUserTask() && (Task::getCurrent()->taskId == owner);
  }

private:
  inline bool isBound() { return (&this->data()!=__null); }
public:
  inline bool isAbsolutelyReady() {
    bool result = isBound() && !this->owner; ;
    return result;
  }

public:
  inline MObj() : owner(-1) {}
  inline MData<type>* operator= (MData<type> *data) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3404); ((int*)0)[0]=0;}};
    return (MData<type>*) (*(SCell<dataHandler>*)this = data);
  }
  inline void waiting() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3408); ((int*)0)[0]=0;}};
    {if (!(Task::inUserTask())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "Task::inUserTask()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3409); ((int*)0)[0]=0;}};




    Freezer::TemporaryOff _f;
    ;
    {
      Task::Holder __holder(&systemRootTask());
      stopHereAndRunOthers();
    }
    ;
    {if (!(cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3421); ((int*)0)[0]=0;}};
   }

  inline MData<type>* getData() {
    ;
    {if (!(cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3426); ((int*)0)[0]=0;}};
    if (isOwned()) { do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Deadlock detected\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); }
    read();
    while (owner) waiting();
    {if (!(&data() != __null)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "&data() != NULL" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3430); ((int*)0)[0]=0;}};
    return (MData<type>*)&data();
  }
# 3445 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
protected:

  inline void unlock() {
    ;



    write();



  }
  inline void lockBy(long long _owner) {
    {if (!(_owner > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "_owner > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3458); ((int*)0)[0]=0;}};
    if (_owner == owner) return;
    {if (!(owner == -1)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "owner == -1" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3460); ((int*)0)[0]=0;}};
    owner = _owner;
  }
  inline void lock() { if (Task::getCurrent()) lockBy(Task::getCurrent()->taskId); }

 protected:
  inline void onWrite() {
    owner = 0;
    contTasks();
  }
public:

  void chunkSetLg(int) {
  }
  virtual ~MObj() {
    ;
  }
  virtual void takeWE() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3478); ((int*)0)[0]=0;}};
    if (master() == myRank) {
      take(we);
    } else { ;


      inDRCwaiting++;
      while (we < (1ll << 16)) {
        if (!takeRqSent) {



          dataHandler

                     .asyncSend(new DRCData(ptr(), (Data<dataHandler>::OnRecvMethod)&ts::DRCObj::onTake, we, "takeWE"), master());
          we = 0;
          takeRqSent = 1;
 }

        if (Task::inUserTask()) waiting();
        else {
          Freezer::TemporaryOff _f;
          while (takeRqSent) { dataHandler.work(); sched_yield(); }
        }



      }
      inDRCwaiting--;
    }
  }
  virtual void retrieveWE() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3510); ((int*)0)[0]=0;}};
     ;
    if (master() == myRank) {
      retrieve(we);
    } else { ;
      if (we == 0) return;
      dataHandler.asyncSend(new DRCData(ptr(), (Data<dataHandler>::OnRecvMethod)&ts::DRCObj::onRetrieve, we, "retrieve"), master());
      we = 0;
    }
  }
private:
  void* operator new (size_t) {return __null;}
  void* operator new[] (size_t) {return __null;}
};
inline bool MThread::finishCondition() { return false; }

template <typename type>
inline MObj<type>& MRef<type>::operator* () const { return *getMObjPtr(); }

template <typename type>
inline void MRef<type>::ctor(MObj<type>* mo) {
  ;
  DRCRef::ctor(mo ? mo : __null);
  SPtr<dataHandler>::operator = (mo);



    pflags = tc().pflags;
}

template <typename type>
inline void MRef<type>::dtor () {
  DRCRef::dtor();
  *(SPtr<dataHandler>*)this = __null;
}

template <typename type>
DRCObj& MRef<type>::getObj() {
  {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3548); ((int*)0)[0]=0;}};
  MObj<type> *mo = getMObjPtr();
  if (mo) {if (!(mo->drcObjOk() && mo->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "mo->drcObjOk() && mo->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3550); ((int*)0)[0]=0;}};
  return (DRCObj &)*mo;
}
# 3580 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class TaskBoard : public StaticSegment<StaticCell<controlHandler>,controlHandler,(5),(4+2)> {
public:
  inline StaticCell<controlHandler>& resourceCell(int rank) { return (*this)[(5)*rank]; }
  inline Resource& resourceAt(int rank) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3584); ((int*)0)[0]=0;}};
    if (rank != myRank) resourceCell(rank).read();
    MControlData<Resource> *d = (MControlData<Resource> *)&resourceCell(rank).data();
    if (!d) resourceCell(rank) = d = new MControlData<Resource>();
    d->vid = "resource";
    return (*d)();
  }
  inline StaticCell<controlHandler>& statisticCell(int rank) { return (*this)[(5)*rank+1]; }
  inline Statistic& statisticAt(int rank) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3593); ((int*)0)[0]=0;}};
    if (rank != myRank) statisticCell(rank).read();
    MControlData<Statistic> *d = (MControlData<Statistic> *)&statisticCell(rank).data();
    if (!d) statisticCell(rank) = d = new MControlData<Statistic>();
    d->vid = "statistic";
    return (*d)();
  }
  inline StaticCell<controlHandler>& readyCell(int rank) { return (*this)[(5)*rank+2]; }
  inline char& readyAt(int rank) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3602); ((int*)0)[0]=0;}};
    if (rank != myRank) readyCell(rank).read();
    MControlData<char> *d = (MControlData<char> *)&readyCell(rank).data();
    if (!d) {
      readyCell(rank) = d = new MControlData<char>();
      d->vid = "ready";
      (*d)() = 0;
    }
    return (*d)();
  }
  inline StaticCell<controlHandler>& msgStatCell(int rank) { return (*this)[(5)*rank+3]; }
  StaticCell<controlHandler>& heartbeatCell() { return sharedCell(0); }
  int& heartbeatData() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3615); ((int*)0)[0]=0;}};
    MControlData<int> *d = (MControlData<int> *)&heartbeatCell().data();
    if (!d) {
      heartbeatCell() = d = new MControlData<int>();
      d->vid = "heartbeat";
      (*d)() = 0;
    }
    return (*d)();
  }
  StaticCell<controlHandler>& relaxCell() { return sharedCell(1); }
  char& relaxData() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3626); ((int*)0)[0]=0;}};
    MControlData<char> *d = (MControlData<char> *)&relaxCell().data();
    if (!d) {
      relaxCell() = d = new MControlData<char>();
      d->vid = "relax";
      (*d)() = 0;
    }
    return (*d)();
  }
  FreeResource *myFreeRes;
  Resource *zeroRes;
  TaskBoard() : myFreeRes(new FreeResource), zeroRes(new Resource) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3638); ((int*)0)[0]=0;}};
    myStat = &statisticAt(myRank);
    resourceAt(myRank) = *myFreeRes;
    resourceCell(myRank).write();
  }
  void deleteSuperCells() {
    for (int j=0;j<(4+2);j++)
      ((SCell<controlHandler>&)(sharedCell(j))) = 0;
    for (int i=0; i<realsuperSize; i++)
      for (int j=0; j<(5);j++)
 ((*this)[(5)*i+j]) = 0;
  }
  virtual ~TaskBoard(){
    deleteSuperCells();
    delete myFreeRes;
    delete zeroRes;
  }
  inline bool publish(Resource& res) { ;
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3656); ((int*)0)[0]=0;}};
    if (!(resourceAt(myRank) == res)) {
      resourceAt(myRank) = res;
      resourceCell(myRank).write();
      return true;
    } else {
      return false;
    }
  }
  int mostHeavyTaskMFlops() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3666); ((int*)0)[0]=0;}};
    int i;
    int minMFlops = 0;
    for (i=0; i<realsuperSize; i++) if (i!=myRank && resourceAt(i).mflops < minMFlops) minMFlops = resourceAt(i).mflops;
    return minMFlops;
  }
  int mostFreeRank(int taskMFlops) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3673); ((int*)0)[0]=0;}};
    int maxMFlops = 0, rankFound = -1, i = myRank;
    for (i=(i+1)%realsuperSize; i != myRank; i=(i+1)%realsuperSize) {
      Resource& res = resourceAt(i);
      ;
      if (taskMFlops <= res.wantedTaskMFlops && res.mflops > maxMFlops) {
 rankFound = i; maxMFlops = res.mflops; ;
      }
    }
    return rankFound;
  }
  int routeTask(Task *t, int tryToRunWhere) {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3685); ((int*)0)[0]=0;}};
    int atRank = (*t)().atRank;
    if (atRank == -1) atRank = tryToRunWhere;
    if (atRank == -1) return -1;
    if (atRank == myRank) {
      {if (!(t->ringEmpty())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "t->ringEmpty()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3690); ((int*)0)[0]=0;}};
      tq.put(*t, false);
      t->activate();
      statisticCell(myRank).write();
      myStat->tasksActivated++;
    } else {
      if (!t->packed) t->packState();
      if ((*t)().atRank < 0) resourceAt(atRank).mflops = 0;



      controlHandler.asyncSend(t,atRank);

      myStat->tasksExported++;
    }
    return atRank;
  }
};
class MacroScheduler : public Service {
  class Heartbeat : public Prof {
    int lastHeartbeat;
    MacroScheduler* ms;
  public:
    Heartbeat(MacroScheduler *_instance):lastHeartbeat(0),ms(_instance) { start(); };
    void check() {
      stop();







      if (ms->tb.heartbeatData() < 0) {




  exitServices(0);
 goto out;
      }
# 3745 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    out:
      start();
    }
  };
  Heartbeat hb;
public:
  TaskBoard tb;
  static MacroScheduler* (*New)(void);
  static MacroScheduler* New_default() {
    return new MacroScheduler;
  };
  MacroScheduler(): Service( __FUNCTION__,4 ),hb(this) {
    ;
  }
  virtual ~MacroScheduler() {}
  virtual bool visit() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3761); ((int*)0)[0]=0;}};
    if (ptq.count > 1) { ;
      Task* t = ptq.pop(true);
      {if (!(t != __null)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "t != NULL" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3764); ((int*)0)[0]=0;}};
      if (tb.routeTask(t,tb.mostFreeRank((*t)().mflops)) >= 0) {
 return true;
      } else {
 ptq.put(*t, true);
 return tb.publish((*t)());
      }
    } else if (ptq.count == 1) {
      return tb.publish(*tb.zeroRes);
    } else {
      int mflops = tb.mostHeavyTaskMFlops();
      if (mflops < 0) {
 tb.myFreeRes->wantedTaskMFlops = mflops;
 return tb.publish(*tb.myFreeRes);
      } else {
 return false;
      }
    }
  }
  bool runLocalTasks() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3784); ((int*)0)[0]=0;}};
    ThrQS& tqs = ThrQS::tqs();
    bool have_tasks = tqs.hasReadyThreads();
    Task *t;
    if (!have_tasks && (t = ptq.pop(false))) {
      tb.routeTask(t,myRank);
    }
    have_tasks = tqs.hasReadyThreads();
    if (have_tasks) {
      Task::setCurrent(&systemRootTask());
      Task::setCurrent(&schedTask);
      tqs.run();
    } else {
      Task::setCurrent(&idleTask());
      Task::setCurrent(&schedTask);
    }
    return have_tasks;
  }
  void setStatistic() {
    {if (!(thread_self() == 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "thread_self() == 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3803); ((int*)0)[0]=0;}};
    {if (!(Task::getCurrent()->isSystemRoot())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "Task::getCurrent()->isSystemRoot()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3804); ((int*)0)[0]=0;}};
    systemRootTask().leave();
    myStat->alive = false;
    myStat->total_time = tick2Sec(rootTask().time);
    myStat->tasks_time = 0;
    myStat->idle_time = 0;



    for (int i = 0; i < thread_ncpu(); i++) {

      myStat->tasks_time += tick2Sec(userRootTask[i].time);
      myStat->idle_time += tick2Sec(idleTask[i].time);
    }
    myStat->sched_time = tick2Sec(schedTask.time);
    myStat->mpi_time = tick2Sec(mpiTask.time);
    myStat->msgsSent = mpiTask.msg_count;
    myStat->msgsAsyncSent = mpiTask.async_msg_count;
    myStat->msgsSize = mpiTask.msg_size;
    tb.statisticCell(myRank).write(); ;
  }
  bool mainStatisticReady() {
    int i;
    for (i = 0; i < realsuperSize; i++) if (tb.statisticAt(i).alive) return false;
    return true;
  }
# 3849 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  void printStatistic() {
    do { do { { VizStr msgstr("%-20s ", "Tasks activated"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->tasksActivated) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).tasksActivated; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).tasksActivated; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%Ld""/""%Ld""/""%Ld""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%Ld"" ", tb.statisticAt(i).tasksActivated); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Tasks exported"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->tasksExported) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).tasksExported; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).tasksExported; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%Ld""/""%Ld""/""%Ld""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%Ld"" ", tb.statisticAt(i).tasksExported); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Msgs sent"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->msgsSent) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).msgsSent; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).msgsSent; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%Ld""/""%Ld""/""%Ld""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%Ld"" ", tb.statisticAt(i).msgsSent); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Async Msgs"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->msgsAsyncSent) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).msgsAsyncSent; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).msgsAsyncSent; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%Ld""/""%Ld""/""%Ld""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%Ld"" ", tb.statisticAt(i).msgsAsyncSent); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Msgs size"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->msgsSize) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).msgsSize; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).msgsSize; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%Ld""/""%Ld""/""%Ld""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%Ld"" ", tb.statisticAt(i).msgsSize); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Taskboard visits"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->visit_count) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).visit_count; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).visit_count; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%d""/""%d""/""%d""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%d"" ", tb.statisticAt(i).visit_count); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Scheduler time"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->sched_time) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).sched_time; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).sched_time; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%.3lf""/""%.3lf""/""%.3lf""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%.3lf"" ", tb.statisticAt(i).sched_time); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "MPI time"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->mpi_time) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).mpi_time; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).mpi_time; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%.3lf""/""%.3lf""/""%.3lf""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%.3lf"" ", tb.statisticAt(i).mpi_time); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Idle time"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->idle_time) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).idle_time; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).idle_time; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%.3lf""/""%.3lf""/""%.3lf""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%.3lf"" ", tb.statisticAt(i).idle_time); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Tasks time"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->tasks_time) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).tasks_time; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).tasks_time; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%.3lf""/""%.3lf""/""%.3lf""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%.3lf"" ", tb.statisticAt(i).tasks_time); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
    do { do { { VizStr msgstr("%-20s ", "Total time"":"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); if (realsuperSize > 1 ) { typeof(myStat->total_time) min,max,avg,tmp; min=max=avg=tb.statisticAt(0).total_time; for (int i=1; i<realsuperSize; i++) { tmp = tb.statisticAt(i).total_time; if (min >= tmp) min = tmp; if (max <= tmp) max = tmp; avg += tmp; } avg /= realsuperSize; do { { VizStr msgstr(" [""%.3lf""/""%.3lf""/""%.3lf""] ", min, avg, max); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } else { for (int i=0; i<realsuperSize; i++) do { { VizStr msgstr("%.3lf"" ", tb.statisticAt(i).total_time); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } do { { VizStr msgstr("\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0); } while (0);
  }

  virtual void exchangeByResources() {
    int i, realRess;
    do {
      Service::service[0]->work();
      for (realRess = 0, i = 0; i < realsuperSize; i++) realRess += !!tb.resourceAt(i).mflops;
    } while (realRess < realsuperSize);
    ;
    tb.readyAt(myRank) = 1;
    tb.readyCell(myRank).write();
    ;
    do {
      Service::service[0]->work();
      for (realRess = 0, i = 0; i < realsuperSize; i++) realRess += !!tb.readyAt(i);
    } while (realRess < realsuperSize);
    ;






   }
  void printClusterResources() {
    Resource *r;
    if (realsuperSize > 1) {
      do { { VizStr msgstr("("); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      int i, cnt = 0;
      Resource total;
      Resource *p = __null;
      for (i = 0; i < realsuperSize; i++) {
 r = &tb.resourceAt(i);
 {if (!(r->mflops > 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "r->mflops > 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3894); ((int*)0)[0]=0;}};
 if ((i == 0) || (r->bogomips != p->bogomips) || (r->mbytes != p->mbytes)) {
          if ((i != 0) && (cnt > 1)) do { { VizStr msgstr("*%d",cnt); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
   do { { VizStr msgstr("%s%s", i?"+":"", r->viz()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
   cnt = 1;
 } else cnt++;
 total += *r;
 p = r;
      }
      if (cnt > 1) do { { VizStr msgstr("*%d",cnt); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      do { { VizStr msgstr(") ~= %s\n", total.viz()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    } else {
      do { { VizStr msgstr("%s\n", tb.resourceAt(myRank).viz()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    }
  }
  bool tryShutdownDataHandler() {
     {if (!(myRank == 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "myRank == 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3910); ((int*)0)[0]=0;}};
     int rank;
     int count;
     MPIMsgStat cur;
     static MPIMsgStat last;
     count = 0;
     for (rank = 0; rank < realsuperSize; rank++) {
       MControlData<MPIMsgStat> *d = (MControlData<MPIMsgStat>*)&tb.msgStatCell(rank).data();
       if (d == 0) {
         tb.msgStatCell(rank).read();
        return false;
       }
       count++;
       cur += (*d)();
     }
     {if (!(count == realsuperSize)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "count == realsuperSize" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3925); ((int*)0)[0]=0;}};
     for (rank = 1; rank < realsuperSize; rank++) {
       tb.msgStatCell(rank) = __null;
     }
     if (!cur.equal()) return false;
     if (cur == last) {
       return true;
     }
     last = cur;
     return false;
  }
  virtual bool work() {
    hb.check();
    static bool relaxed = false;
    static bool gotRelax = false;
    static bool canShutdown = false;
    static bool statisticReady = false;
    ;
    if (tb.relaxData() && !gotRelax) {



      ptq.clear();
      gotRelax = true;
    }
    if (gotRelax && !relaxed) {
      if (thread_self() != 0) {
        Task::setCurrent(&systemRootTask());
 Service::exitThread();
 return false;
      }
      if (Service::threadExited < (thread_ncpu() - 1)) return false;
      Task::setCurrent(&systemRootTask());
      {if (!(thread_self() == 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "thread_self() == 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",3958); ((int*)0)[0]=0;}};
      if (tq.count > 0) {
        do { { VizStr msgstr("main result is ready and %d TFuns are still working. Memory leaks are possible.\n", tq.count); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
      }
      MControlData<MPIMsgStat> *d = new MControlData<MPIMsgStat>();
      tb.msgStatCell(myRank) = d;
      d->vid = "msgstat";
      setStatistic(); ;
      relaxed = true;
    }
    if (relaxed) {
      MControlData<MPIMsgStat> *d = (MControlData<MPIMsgStat> *)&tb.msgStatCell(myRank).data();
      (*d)() =



                              dataHandler.getStat();
      tb.msgStatCell(myRank).write();
      if (myRank == mainRank) {
 if (!canShutdown && tryShutdownDataHandler()) canShutdown = true;
      }
    }
    if (myRank == mainRank) {
      if (relaxed) {
 if (!statisticReady) statisticReady = mainStatisticReady();
 if (statisticReady && canShutdown) {
   tb.heartbeatData() = -1;
   tb.heartbeatCell().write(); ;
 }
 return false;
      } else {
 bool mainResultReady();
 if (mainResultReady()) {
   tb.relaxData() = 1; ;
   tb.relaxCell().write();
   return false;
 }
      }
    }
    static bool last_result = false;
    bool result;
    {
      Task::setCurrent(&schedTask);
      myStat->visit_count++;
      result = visit();
      bool has_tasks = runLocalTasks();
      result = result || has_tasks;
      if (has_tasks)
 Task::setCurrent(&systemRootTask());
      else
 Task::setCurrent(&idleTask());
    }
    last_result = result;
    return result;
  }
};


template <typename type>
class TData : public MData<type> {
public:
  TData() {}
  TData(const TData& m) : MData<type>(m) {}
  virtual bool isReady() const = 0;
};
template <typename type>
class TDataReady : public TData<type> {
private:
  type val;
public:
  char __end[0];
  inline type& operator ()() { return val; }
  virtual bool isReady() const { return true; }
  inline TDataReady() {



  }
  inline TDataReady(const TDataReady& m) : TData<type>(m), val(m.val) {
    ;
    {if (!(m.size == this->size)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m.size == this->size" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4038); ((int*)0)[0]=0;}};



   }
  inline TDataReady<type>& operator= (const TDataReady<type>& m) {
    ;
    {if (!(m.size == this->size)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m.size == this->size" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4045); ((int*)0)[0]=0;}};

    {if (!(this->ptr == m.ptr)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->ptr == m.ptr" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4047); ((int*)0)[0]=0;}};



; this->val = m.val; ;
    return *this;
  }
  virtual SData* clone () {
    SData* result = (SData*) new (TDataReady<type>::halloc(this->size)) TDataReady<type>(*this);
    size_t stdSize = (char *)(&this->__end[0]) - (char *)this, extraSize = this->size - stdSize;
    {if (!(extraSize >= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "extraSize >= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4057); ((int*)0)[0]=0;}};
    if (extraSize > 0)
      memcpy((char*)result + stdSize,(char*)this + stdSize, extraSize);
    return result;
  }
};
template <typename type>
class TObj;



template <typename type>
class TDsc : public MRef<type> {
public:
  inline TDsc() {



}
  inline TDsc(const TDsc<type>& d) {

    (*this) = &d();







  }
  inline TDsc<type>& operator= (const TDsc<type> d) {
    (*this) = &d();
    return *this;
  }
  inline TDsc(TObj<type>*);
  inline TObj<type>* operator= (TObj<type>*);
  inline TObj<type>& operator()() const {
    return *getTObjPtr();
  }
  inline TObj<type>* getTObjPtr() const { return (TObj<type> *)this->getMObjPtr(); }
  inline void drop();
  virtual ~TDsc() { }

  inline bool isLocal() const {
    return this->isNull() || getTObjPtr()->isLocal();
  }
  inline bool isGlobal() const { return !isLocal(); }
  inline void localize();



  virtual const char *info() const { return "TDsc: <no info available>"; }
 };
class AnyType {};
template <typename type>
class TDataNotReady;
template <typename type>
class TObj : public MObj<type>



 {
public:
  TDsc<type> dth;
  size_t initialExtraSize;





private:
  bool local;
public:
  inline bool isLocal() const { return local; }
  inline bool isGlobal() const { return !local; }
  inline void setGlobal() { local = false; }
  inline void setUnlock() { setGlobal(); this->unlock(); }




  inline void setOwner(long long owner) { this->lockBy(owner); }
public:

  inline TObj(bool locked=true) : dth(__null), initialExtraSize(tc().extraSize), local(true) { if (locked) this->lock(); }





private:
   inline TObj(const TObj<type>& t) : dth(__null), initialExtraSize(0) { {if (!(0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4148); ((int*)0)[0]=0;}}; }
private:
  inline void makeUnbound() {
    *this = (TData<type>*)__null;



  }
public:
  inline TData<type>* operator= (TData<type> *data) {
; *(SCell<dataHandler>*)this = data; ;
    return data;
  }
public:

  inline operator type () {
    {if (!(isLocal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isLocal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4164); ((int*)0)[0]=0;}};



     return (*this)()();
  }
# 4211 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  inline TDataReady<type>& operator()() {
    {if (!(isLocal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isLocal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4212); ((int*)0)[0]=0;}};
    TData<type>* td = (TData<type>*)&this->data();
    if (td == __null) {
      TDataReady<type>* t = new (TDataReady<type>::halloc(sizeof(TDataReady<type>)+initialExtraSize)) TDataReady<type>;
      *this = t;
      return *t;
    } else
    if (td->isReady()) {
      return *(TDataReady<type>*)td;
    } else {
      do {
        TObj<type>* curr = ((TDataNotReady<type>*)td)->getTObjPtr();
        td = (TData<type>*) (curr->getData());
 *this = td;
        if (td->isReady()) {
   TDataReady<type>* rd = (TDataReady<type>*) (td->clone());
   *this = rd;
   return *rd;
        }
      } while (1);
    }
  }
# 4263 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
private:
  inline TObj<type>& getMyDrop() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4265); ((int*)0)[0]=0;}};
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4266); ((int*)0)[0]=0;}};



    {if (!(this->isOwned())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->isOwned()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4270); ((int*)0)[0]=0;}};
    TObj<type> *dt = dth.getTObjPtr();
    if (!dt) {
      dt = new TObj<type>; ;

      dt->setGlobal();



      dth = dt;
    }
    return *dt;
  }
public:
  inline TDsc<type> ownerCopy() {
    if (this == __null) return __null;
    ;
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4287); ((int*)0)[0]=0;}};
    {if (!(Task::inUserTask())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "Task::inUserTask()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4288); ((int*)0)[0]=0;}};

    if (!this->isOwned()) return this;





    if (&this->data()!=__null) {
      TObj<type>* t = new TObj<type>;
      *t = &ownerCopyData();
      t->setUnlock();
      TDsc<type> d = t;
      return d;
    } else {
      return &getMyDrop();
    }
  }
  inline TObj<type>& operator= (const type& v) {
    ;
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4308); ((int*)0)[0]=0;}};

    {if (!(isLocal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isLocal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4310); ((int*)0)[0]=0;}};
    TData<type>* td = (TData<type>*)&this->data();
    TDataReady<type>* t;
    if ((td == __null) || !(td->isReady())) {
      t = new (TDataReady<type>::halloc(sizeof(TDataReady<type>)+initialExtraSize)) TDataReady<type>;
      *this = t;
    } else {
      t = (TDataReady<type>*) td;
    }
    (*t)() = v;




    return *this;
  }
  inline TObj<type>& operator= (TObj<type>& t) {
    ;
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4328); ((int*)0)[0]=0;}};

    {if (!(isLocal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "isLocal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4330); ((int*)0)[0]=0;}};

    if (this != &t) {

      if (!t.owner || (t.isOwned() && (&t.data()!=__null))) { ;
        TData<type> *td = (TData<type>*)&t.data();
        *this = td;
 if (td->isReady()) {
          *this = (TData<type>*)(td->clone());
        }
      } else { ;
 *this = new TDataNotReady<type>(t.isOwned()?t.getMyDrop():t);
      }
# 4359 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    } else {
      ;
    }
    return *this;
  }
  void drop(bool doUnbound = true) {
    ;
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4366); ((int*)0)[0]=0;}}; ;

    if (Task::inUserTask() && isLocal()) {




      TObj<type> *dt = dth.getTObjPtr();
      if (dt) {
        {if (!(dt->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "dt->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4375); ((int*)0)[0]=0;}};

        *dt = &ownerCopyData();
# 4387 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
        dt->setUnlock(); ;
      }
    }
    dth = __null;
    if (doUnbound) makeUnbound();
  }
public:

  inline TObj<type>& ownerFreezeCopy() {
    TObj<type>& result = *new TObj<type>;
    result = &ownerCopyData();
    result.setUnlock();
    return result;
  }

  inline TData<type>& ownerCopyData() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4403); ((int*)0)[0]=0;}};
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4404); ((int*)0)[0]=0;}};




    TData<type> *my = (TData<type>*) &this->data();
    if (!my) { do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Drop or freeze on unitialized T-value!"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0); }





    {
      Freezer frz;
      TData<type>* d = (TData<type>*)(my->clone());
      return *d;
    }
  }
public:






  virtual ~TObj() {
    {if (!(this->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4430); ((int*)0)[0]=0;}};
    drop();
; ;
  }
  virtual void dumpLeakCell() {

    if (&this->data() == 0) return;
    do { { VizStr msgstr("[%d] Leaked cell %x,%lld with data %s (%d bytes). Have weight %lld, lcnt %d\n", myRank, this->offset(), this->getSeqNo(), this->data().viz(), this->data().size, this->we, this->lcnt); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
# 4446 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  }






  void* operator new (size_t size) {
    extern DynamicSegment< TObj<AnyType>, dataHandler, ((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) >& tseg();
    return tseg().allocChunk((size+sizeof(TObj<AnyType>)-1)/sizeof(TObj<AnyType>));
  }
  void* operator new[] (size_t size) {
    extern DynamicSegment< TObj<AnyType>, dataHandler, ((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) >& tseg();
    return tseg().allocChunk((size+sizeof(TObj<AnyType>)-1)/sizeof(TObj<AnyType>));
  }
  void operator delete (void* mem, size_t size) {
    extern DynamicSegment< TObj<AnyType>, dataHandler, ((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) >& tseg();
    TObj<AnyType>*m = (TObj<AnyType>*)mem;
    {if (!(m->master() == myRank)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m->master() == myRank" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4464); ((int*)0)[0]=0;}};
    tseg().freeChunk(m, (size+sizeof(TObj<AnyType>)-1)/sizeof(TObj<AnyType>));
  }
  void operator delete[] (void* mem, size_t size) {
    extern DynamicSegment< TObj<AnyType>, dataHandler, ((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) >& tseg();
    TObj<AnyType>*m = (TObj<AnyType>*)mem;
    {if (!(m->master() == myRank)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "m->master() == myRank" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4470); ((int*)0)[0]=0;}};
    tseg().freeChunk(m, (size+sizeof(TObj<AnyType>)-1)/sizeof(TObj<AnyType>));
  }
  void* operator new (size_t size, void *mem) { return mem; }
public:
  class InitDataHandler {
  private:
    static void inPlaceCtor (Cell *c) {
      TObj<type> *t = new (c) TObj<type>(false);

      t->setGlobal();

    }
    static void clearCell (Cell *c) { ((TObj<type>*)c)->clearCell(); }
    static void tssOnWrite (Cell *c) { ((TObj<type>*)c)->tssOnWrite(); }
  public:
    InitDataHandler() {
      dataHandler.onWrite = tssOnWrite;
      dataHandler.inPlaceCtor = inPlaceCtor;
      dataHandler.clearCell = clearCell;
    }
  };
private:
  void clearCell() {
    dth = __null;
    makeUnbound();
    {if (!(this->owner <= 0)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "this->owner <= 0" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4496); ((int*)0)[0]=0;}};
    this->owner = 0;
    this->initialExtraSize = 0;
    ((DRCObj *)this)->~DRCObj();
  }

  void tssOnWrite () {
    Task *savedCurrent = Task::getCurrent();
    Task::setCurrent(&systemRootTask());
    this->onWrite();
    Task::setCurrent(savedCurrent);
  }
# 4565 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
};
template <typename type>
class TDataNotReady : public TData<type> {

private:
  MRef<type> nonReady;





public:
  virtual bool isReady() const { return false; }

  TDataNotReady(TObj<type>& to) {
    nonReady = &to;
  }
# 4593 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  virtual SData* clone () {



    SData* result =
      (SData*) new (TDataNotReady<type>::halloc(this->size)) TDataNotReady<type>(*this);
    return result;
  }
  inline TObj<type>* getTObjPtr() const { return (TObj<type>*)(nonReady.getMObjPtr()); }
};

template <typename type>
inline TDsc<type>::TDsc<type>(TObj<type>* t) {
  *(MRef<type>*)this = t;
}
template <typename type>
inline TObj<type>* TDsc<type>::operator= (TObj<type>* t) { *(MRef<type>*)this = t; return t; }
template <typename type>
inline void TDsc<type>::drop() { if (this->notNull()) getTObjPtr()->drop(

false

); }

template <typename type>
inline void TDsc<type>::localize() {
  if (this->isNull()) return;
  if (this->isLocal()) return;
  TObj<type> *t = new TObj<type>;
  *t = new TDataNotReady<type>(*(getTObjPtr()));
  *this = t;
}

extern DynamicSegment< TObj<AnyType>,dataHandler,((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) > _tseg;
extern DynamicSegment< TObj<AnyType>,dataHandler,((0x800000/(sizeof(TObj<AnyType>)*24)) - (0x10)) >& tseg();





template <typename type> class TVar ;

template <typename type>
class TFrz {
  int magic;
  TDsc<type> d;
public:
  inline bool ok() const { return magic == 0x1223331; }

  TObj<type>& operator()() const { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4642); ((int*)0)[0]=0;}}; return d(); }
  operator TObj<type>& () const { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4643); ((int*)0)[0]=0;}}; return d(); }
  operator type () const {
    {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4645); ((int*)0)[0]=0;}};
    if (Task::inUserTask()) {
      TDsc<type> t = d;
      t.localize();
      return t()()();
    }
    TData<type>* data = (TData<type>*)&(d().data());
    if (data->isReady()) {
      return (*(TDataReady<type>*)data)();
    } else {
      do { do { { VizStr msgstr("\n\n[%d]: ", myRank); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("Sorry, dude. I can't wait for data here.\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); do { { VizStr msgstr("\n\n"); ui->write(bright(Red),msgstr.close()); } VizStr::rewind(); } while(0); exit(1); } while(0);
      return d()()();
    }
  }





  const char * info() const { return d.info(); }
  inline TFrz() : magic(0x1223331), d(__null) {};
  inline ~TFrz() { magic = 0; }
  inline type operator+ (TFrz<type> t) { return (type)(*this) + (type)t; }
  inline type operator- (TFrz<type> t) { return (type)(*this) - (type)t; }
  inline type operator* (TFrz<type> t) { return (type)(*this) * (type)t; }
  inline type operator/ (TFrz<type> t) { return (type)(*this) / (type)t; }

  inline TFrz(type v) : magic(0x1223331),d(new TObj<type>) { Freezer frz; d()()() = v; d().setUnlock(); {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4672); ((int*)0)[0]=0;}}; }
  inline TFrz(TObj<type>* t) : magic(0x1223331),d(t->ownerCopy()) { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4673); ((int*)0)[0]=0;}}; }
  inline TFrz(TObj<type>& t) : magic(0x1223331),d(t.ownerCopy()) { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4674); ((int*)0)[0]=0;}}; }
  inline TFrz(const TDsc<type>& t) : magic(0x1223331),d(t().ownerCopy()) { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4675); ((int*)0)[0]=0;}}; }
  inline TFrz(const TVar<type>& t) : magic(0x1223331),d(((TObj<type>&)((TVar<type>&)t)).ownerCopy()) { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4676); ((int*)0)[0]=0;}}; }
  inline TFrz(const TFrz<type>& t) : magic(0x1223331),d(&t()) { {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4677); ((int*)0)[0]=0;}}; }
  inline TFrz<type>& operator = (const TFrz<type> t) { d = &t(); {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4678); ((int*)0)[0]=0;}}; return *this; }
# 4689 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  inline void reset() { d = __null; }
};
template <typename type>
class TPtr {
private:
  TDsc<type> d;
public:
  inline TPtr() {}
  inline TPtr(const TObj<type>* t) {
    ;
    d = (TObj<type>*)t;
  }
  inline TObj<type>* operator= (TObj<type>* t) {
    d = (TObj<type>*)t; ;
    return d.getTObjPtr();
  }

  inline TObj<type>* operator= (TFrz<type> frz) {
    d = &(TObj<type>&)frz;
    return d.getTObjPtr();
  }

  inline TPtr(const TPtr<type>& t) {






    *this = t;
  }
  inline TPtr<type>& operator= (const TPtr<type>& t) {
    ;
    if (t.d.isNull()) {
; d = __null; ;
    } else {
      {if (!(t.d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "t.d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4725); ((int*)0)[0]=0;}};

      if (!Freezer::isOn() || t.d.isGlobal()) {
; d = t.d.getTObjPtr(); ;




      } else {
; d = t.d().ownerCopy(); ;
      }
    }
    return *this;
  }
  inline operator type* () {
    if (d.isNull()) return __null;
    d.localize();
    return &d()()();
  }
  inline operator bool () const { return d.notNull(); }
  inline type* operator->() {
    type *p = (type*)*this;
    if (p == __null) do { { VizStr msgstr("\nNULL TPtr dereference (operator ->)\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    return p;
  }
  inline void drop() {
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4751); ((int*)0)[0]=0;}};
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4752); ((int*)0)[0]=0;}};
    d.drop();
  }
  inline TObj<type>& operator* () { d.localize(); return d(); }
  inline const TObj<type>& operator* () const { d.localize(); return d(); }
  inline const bool operator == (TPtr<type>& t) const { return d == t.d; }
  inline const bool operator != (TPtr<type>& t) const { return d != t.d; }
};
# 4775 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
template <typename type>
class TVar {
protected:
  TDsc<type> d;
public:
  inline TObj<type>& operator()() {
    d.localize();
    return d();
  }
public:
  inline TVar() : d(new TObj<type>) {



    ;
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4790); ((int*)0)[0]=0;}};
  }
  inline TVar(type v) : d(new TObj<type>) {
    ;
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4794); ((int*)0)[0]=0;}};
    d()()() = v;
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4796); ((int*)0)[0]=0;}};
  }
  inline TVar<type>& operator= (const type& v) {
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4799); ((int*)0)[0]=0;}};
    (*this)() = v;
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4801); ((int*)0)[0]=0;}};
    return *this;
  }
  inline TVar(TObj<type>& t) : d(new TObj<type>) {
    ;
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4806); ((int*)0)[0]=0;}};



    d() = t;
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4811); ((int*)0)[0]=0;}};
  }

  inline TVar(const TVar<type>& v) : d(__null) {
    ;
    if (v.d.isGlobal()) {
      d = v.d;
    } else {
      d = new TObj<type>;
      *this = v;
    }
    if (Freezer::isOn()) {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4822); ((int*)0)[0]=0;}};
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4823); ((int*)0)[0]=0;}};
  }
# 4841 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  inline TVar<type>& operator= (TObj<type>& to) {
    ;




    TObj<type>& t = (*this)();
     if (!Freezer::isOn()) {
      t = to; ;
    } else {

      d = to.ownerCopy();
      {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4853); ((int*)0)[0]=0;}};
# 4865 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
    }
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4866); ((int*)0)[0]=0;}};
    return *this;
  }
  inline TVar<type>& operator= (const TVar<type>& v) {
    {if (!(v.d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "v.d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4870); ((int*)0)[0]=0;}};
    return (*this) = v.d();
  }

  inline TVar(const TFrz<type>& frz) : d(__null) {
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4875); ((int*)0)[0]=0;}};
    d = &((TFrz<type>&)frz)();
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4877); ((int*)0)[0]=0;}};
  }






  inline TVar<type>& operator= (TFrz<type> frz) {

    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4887); ((int*)0)[0]=0;}};
    if (Freezer::isOn()) {
      d = &frz();
      {if (!(d.isGlobal())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d.isGlobal()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4890); ((int*)0)[0]=0;}};
    } else {
      (*this)() = new TDataNotReady<type> (frz());
    }




    return *this;
  }
  inline void drop() {
    {if (!(!Freezer::isOn())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!Freezer::isOn()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4901); ((int*)0)[0]=0;}};
    {if (!(d().cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "d().cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4902); ((int*)0)[0]=0;}};
    d.drop();
  }
  inline TVar<type>* ampersand() const { return (TVar<type>*)this; }
  inline TObj<type>* operator& () { return &(*this)(); }
  inline operator type& () { return (*this)()()(); }
  inline type& operator += (type n) { return (*this)()()() += n; }
  inline type& operator -= (type n) { return (*this)()()() -= n; }
  inline type& operator ++ () { return ++(*this)()()(); }
  inline type& operator -- () { return --(*this)()()(); }
  inline type operator ++ (int) { return (*this)()()()++; }
  inline type operator -- (int) { return (*this)()()()--; }
  inline type operator+ (TObj<type>& t) { return (*this)()()() + t()(); }
  inline type operator- (TObj<type>& t) { return (*this)()()() - t()(); }
  inline type operator* (TObj<type>& t) { return (*this)()()() * t()(); }
  inline type operator/ (TObj<type>& t) { return (*this)()()() / t()(); }
  inline type operator+ (type t) { return (*this)()()() + t; }
  inline type operator- (type t) { return (*this)()()() - t; }
  inline type operator* (type t) { return (*this)()()() * t; }
  inline type operator/ (type t) { return (*this)()()() / t; }
  inline operator TObj<type>& () { return (*this)(); }
};
extern ThreadLocal<long> toutChain;
class toutChainReset {
public:
  toutChainReset() { toutChain() = 0; }
};
template <typename type>
class TOut : public TVar<type> {
  long nextOffset;
  char sign;
public:
  inline TOut<type>* next() {
    TOut<type>* res = (TOut<type>*) (nextOffset+(long)this);
    {if (!(res->sign == 'o')) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "res->sign == 'o'" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4936); ((int*)0)[0]=0;}};
    return res;
  }
  TOut() : nextOffset(0), sign('o') {
    ;
    if (!toutChain())
      toutChain() = (long)this;
    else {
      nextOffset = (long)((TOut<type>*)toutChain())->next() - (long)this;
      ((TOut<type>*)toutChain())->nextOffset = (long)this - toutChain();
    }
  }
  const char * info() const {
    String str;
    str.printf("TOut %s",(*(TOut<type>*)this)().info());
    return str.close();
  }
  void pack() {
    TObj<type> *to = &(*this)();
    {if (!(to->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "to->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4955); ((int*)0)[0]=0;}};



    this->d = to->dth;
  }
  void unpack(long long taskId) {

    TObj<type> *to = new TObj<type>(false);



    to->setOwner(taskId);



    if (this->d.notNull()) {
      TObj<type> *dropTo = this->d.getTObjPtr(); ;
      dropTo->setOwner(taskId);
      {if (!(dropTo->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "dropTo->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4974); ((int*)0)[0]=0;}};

      to->dth = dropTo;




    }
    this->d = to;
    {if (!(to->cellIsOk())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "to->cellIsOk()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",4983); ((int*)0)[0]=0;}};
  }
  TObj<type>& operator= (TObj<type>& to) {
    (*this)() = to;
    return (*this)();
  }
  TObj<type>& operator= (const type& v) {
    (*this)()()() = v;
    return (*this)();
  }
  TObj<type>& operator= (TFrz<type> frz) {
    ;
    if (!frz.ok()) {
      do { { VizStr msgstr("TFun %s didn't return any value.\n" "It is a user bug. Dumping stack and exit...\n", Task::getCurrent()->context().name()); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);

      fault();
    }
    (*this)() = frz();
    return (*this)();
  }
};
# 5070 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
class TFunCtxt : public TaskCtxt {
public:
  TFunCtxt(char *name) : TaskCtxt(name) {}
};





template <typename type, TFunCtxt& ctxt>
class TFun : public MThread, toutChainReset {
private:
  long long parentTaskId;
public:
  int tfunId;
  int fflags;
  TOut<type> retval;
  TFrz<type> retfrz;
  TFun() : parentTaskId(parent?parent->taskId:-1), fflags(tc().fflags), retfrz(retval) {
    ;
    if (parentTaskId >= 0) {
      do { if (ts::conf.generateCallGraph) { static char buf[0x100000]; char *p=buf, *e=buf+sizeof(buf)-1; p += snprintf(p,e-p,"\ncallGraph\t"); p += snprintf(p,e-p,"\tf%Lx -> f%Lx;\n", parent->taskId, taskId); p += snprintf(p,e-p,"\n"); fprintf(stderr, "%s\n", buf); } } while (0);
    }
  }
  TFunCtxt& context() {
    return ctxt;
  }
  virtual void packState() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",5098); ((int*)0)[0]=0;}};
    Task::packState();
    TOut<type>* t = (TOut<type>*)retval.ampersand();
    do t->pack(); while ((t = t->next()) != retval.ampersand());
  }
  virtual void unpackState() {
    {if (!(tsLocked())) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "tsLocked()" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",5104); ((int*)0)[0]=0;}};
    TOut<type>* t = (TOut<type>*)retval.ampersand();
    do t->unpack(taskId); while ((t = t->next()) != retval.ampersand());
  }






  const char *name() {
    char *p = demangle(typeid(*this).name()), *q;
    if ((q=strstr(p,"TFunImpl"))) *q = 0;
    if ((q=strstr(p,"ts::TFun"))) {
      if ((q = strstr(q,", ")) ) {
 p = q+2;
 if (( q = strstr(p,"TFun")) ) *q = 0;
      }
    }
    if (!strcmp(p,"tfunmain")) p += 4;
    return p;
  }
  const char* toutInfo () {
    String str;
    TOut<type>* t = (TOut<type>*)retval.ampersand();
    do str.printf("%s\n",t->info()); while ((t = t->next()) != retval.ampersand());
    return str.close();
  }
# 5178 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
  static TFun<type,ctxt>* tryToReuseMemo(TFun<type,ctxt>* tf, void* key, size_t keySize) {
    if (tc().memoize) {
# 5211 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
      static int warnCnt = 0;
      if (!warnCnt++)
 do { { VizStr msgstr("WARN: memoization is not supported; please enable it in tssconfig.h\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);

    }
    return tf;
  }
  virtual void work() {

    static char * clr[] = {"yellow", "red", "green", "blue", "magenta", "cyan"};
    const int clrQty = sizeof(clr)/sizeof(clr[0]);

    try {
      ;
      ;
      {
 ;
 retval = body();
      }
      do { if (ts::conf.generateCallGraph) { static char buf[0x100000]; char *p=buf, *e=buf+sizeof(buf)-1; p += snprintf(p,e-p,"\ncallGraph\t"); p += snprintf(p,e-p,"\tf%Lx [label=\"%s %s\",style=\"filled\",fillcolor=\"%s\"];\n", taskId, name(), this->getLabel(), clr[myRank%clrQty]); p += snprintf(p,e-p,"\n"); fprintf(stderr, "%s\n", buf); } } while (0);

    } catch (FinalizeException e) {
      ;
    }
    ;
  }
  inline void stopAndContParent() {
    setCurrent(parent); ;
    parent = __null;
    if (!(1 & fflags)) run();
  }
  virtual TFrz<type> body() = 0;
  virtual ~TFun() {
    ;
  }
};
class ParentTemporaryOn {
  Task *task;
public:
  ParentTemporaryOn(Task *_task) : task(_task) { Task::setCurrent(task->parent); }
  ~ParentTemporaryOn() { Task::setCurrent(task); }
};
void sleep(double sec=0.);
class DefaultExceptionHandler {
public:
  static void unexpectedException() {
    fprintf(stderr, "%s: may be some 'try {} catch()' missed?\n", __FUNCTION__);
    fprintf(stderr, "%s: terminating program execution\n", __FUNCTION__);
    exit(1);
  }
  void (*savedHandler)();
  DefaultExceptionHandler() {
    savedHandler = std::set_unexpected(unexpectedException);
  }
  ~DefaultExceptionHandler() {
    std::set_unexpected(savedHandler);
  }
};
class TRT : public CmdLine, DefaultExceptionHandler {
public:
  static TRT *trt;
  MacroScheduler *ms;
  TRT(int* argc, char *** argv) : CmdLine(argc,argv),
    ms(MacroScheduler::New())
  {
    {if (!(!trt)) {fprintf(stderr, "[%d] Assertion '%s' failed at '%s' %s:%d\n", ts::myRank, "!trt" ,__PRETTY_FUNCTION__,"/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt",5276); ((int*)0)[0]=0;}};
    trt = this ;
    atexit(atExit);
    Feature::initialize(); ;
    if (conf.enableAsync) (*mpi_portal->_DMPI_Async_init)();
    trt->ms->exchangeByResources();
  }
  static void atExit() {
    ;
    if (!Service::exitFlag()) {



      Task::setCurrent(&systemRootTask());
      (*mpi_portal->_DMPI_Async_disable)();
      if(!trt) return;
      trt->ms->tb.relaxData() = 1;
      trt->ms->tb.relaxCell().write();
      trt->ms->setStatistic();
      ;
    }
  }
  ~TRT() {
    tseg().finalize();
    delete ms;
    trt = __null;
  }
};
class MainTRT {
public:
  MainTRT() {
    do { { VizStr msgstr("Open T-System Runtime v3.0, 2003-2004, PSI RAS, Russia.\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    do { { VizStr msgstr("Running under %s MPI on %d-rank %scluster:\n  ", mpi_portal->name, realsuperSize, dmpi_meta ? "meta":""); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);

    TRT::trt->ms->printClusterResources();
    ;
    ;
    do { { VizStr msgstr("Starting tfun main, good luck!\n\n"); ui->write(((Color)((myRank%4)+Green)), msgstr.close()); } VizStr::rewind(); } while(0);
    ;
  }
  virtual ~MainTRT() {
    ;
    TRT::trt->ms->printStatistic();
    ;
    ;
    ;
    ;
  }
};
enum _sc_name {
  _SC_START = 0x1000,
  _SC_CL_RUN_DATE,
  _SC_CL_CPU_NAME,
  _SC_CL_CPU_FLOPS,
  _SC_NPROCESSORS_CONFIG,
  _SC_CL_SIZE,
  _SC_CL_CLUSTER_FLOPS,
  _SC_CL_MPI_RANK,
  _SC_CL_MPI_IMPL,
  _SC_CL_MPI_OPTIONS,
  _SC_CL_EMULATION,
  _SC_CL_NODE_NAME,
  _SC_CL_OS_VERSION,
  _SC_CL_L1_CACHE_SIZE,
  _SC_CL_L2_CACHE_SIZE,
  _SC_CT_GCC_VERSION,
  _SC_CT_OPTIONS,
  _SC_CT_DEBUG,
  _SC_CT_CHECK,
  _SC_CT_THREAD_IMPL,
  _SC_RT_TASK_BOARD,
  _SC_RT_CELLS,
  _SC_RT_FEATURES,
  _SC_RT_THREAD_POOL,
  _SC_RT_MEMORY_POOL,
  _SC_RT_PARALLEL,
  _SC_RT_PROFILE,
  _SC_RT_TRACE,
  _SC_RT_DEBUG,
  _SC_ENV_STACK_SIZE,
  _SC_ENV_THREAD_PRIO,
  _SC_ENV_PTR_MODE,
  _SC_ENV_MEASURE,
  _SC_ENV_VERBOSE,
  _SC_SUMMARY
};
# 5446 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
long sysconf(int name);
extern
TFrz<int> mainResult;
}
# 5465 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/trt"
extern ts::TFunCtxt tfunmainTFunCtxt; struct tfunmainTArgDef { int argc; char **argv; ts::TFunCtxt* _fid; }; struct tfunmainTFunDef: public ts::TFun<int, tfunmainTFunCtxt>, tfunmainTArgDef { virtual ts::TFrz<int> body() = 0; static tfunmainTFunDef* New(); }; int tfunmainCversion (int argc, char *argv[]); static inline ts::TFrz<int> tfunmain (int argc, char *argv[]) { ts::TSLocker _l; ; tfunmainTFunDef *_tf = tfunmainTFunDef::New(); _tf->argc=argc; _tf->argv=argv ; _tf->stopAndContParent(); _tf = (tfunmainTFunDef*)tfunmainTFunDef::tryToReuseMemo(_tf,(tfunmainTArgDef*)_tf,sizeof(tfunmainTArgDef)); return _tf->retfrz; }

int main(int argc, char *argv[]) __attribute__ ((weak));
# 5 "<command line>" 2
# 1 "t.c"
# 1 "/mnt/storage2/home/vroganov/openTS.msiu/opentxx/../opentss/txx" 1
# 2 "t.c" 2



# 12976 "t.ii"

# 5 "t.c"
 
# 12980 "t.ii"

# 5 "t.c"
 
# 12984 "t.ii"
TFUNDEF(double, fact, (int n), (n), /*static*/, int n ;, { ts::Freezer _f; ts::ParentTemporaryOn _p(_tf); _tf->n = n; }  ;, , )	 TFUNIMPL(double, fact, (int n), (n), /*static*/, int n ;, { ts::Freezer _f; ts::ParentTemporaryOn _p(_tf); _tf->n = n; }  ;, , )	
# 5 "t.c"
 {
  return n < 1 ? 1 : n * fact(n - 1);
}

# 12991 "t.ii"

# 9 "t.c"
 
# 12995 "t.ii"

# 9 "t.c"
 
# 12999 "t.ii"
TFUNIMPL(int, tfunmain, (int argc , char * * argv), (argc , argv), /*static*/, int argc ; char * * argv ;, { ts::Freezer _f; ts::ParentTemporaryOn _p(_tf); _tf->argc = argc; }  ; { ts::Freezer _f; ts::ParentTemporaryOn _p(_tf); _tf->argv = argv; }  ;, , )	
# 9 "t.c"
 {
  if (argc != 2) { printf("Usage: fib <n>\n"); return 1; }
  int n = atoi(argv[1]);

  printf("fact(%d) = %.0lf\n", n, (double)fact(n));
  return 0;
}

# 13010 "t.ii"
