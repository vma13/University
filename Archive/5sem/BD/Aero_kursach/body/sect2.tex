\section{Общее задание}
\subsection{Постановка задачи}
Реализовать  интерфейс для просмотра, редактирования, добавления и удаления следующих составляющих проекта: регистрационных стоек (check - in - desk), посадочных терминалов (terminal), авиакомпаний (company). Также расширить интерфейс по работе с рейсами, добавив туда возможность назначать любому рейсу (удалять назначение, редактировать назначение, просматривать назначение) соответсвующие ему регистрационные стойки (check-in-desk-glight), посадочные терминалы (flight-terminal) и события, происходящие с рейсом(flight-status). Под событиями подразумевается следующая информация: рейс отложен, рейс отменен, рейс на посадочной полосе, рейс влетел, рейс сел, идет посадка на рейс на и т.д.\\
\subsection{Реализация}
1.\emph{Модель.} С помощью методов модели, в соотвествии с концепцией MVC, мы можем модифицировать данные в нашей базе данных. Для этой операции нам необходим объект-посредник между моделью и контреллером, исчерпывающимобразом содержащий информацию о рассматриваемом субъекте (стойке, терминале, и т.д.). Этот объект, собственно, и является информационной моделью. Вполне естественно, что этим объектом служит экземпляр модели. Введем конструктор класса. Пусть экземпляр класса тоже включает в себя ассоциативный массив. Этим ассоциативным массивом служит хеш @attributes, определенный для каждого экземпляра класса(если множество аргументов конструктора пусто, все его значения по умолчанию инициализируется nil'ами). Каждый его ключ - символическая константа, поскольку имена атрибутов на протяжении выполнения программы не изменяются. Один такой хеш - модель одной записи из таблицы. С этим хешем сможет работать и контроллер, и представления.\\
\begin{verbatim}
def intialize(attributes = {})
 @attributes = {
  :id => nil,
  :name => nil,
  :description => nil
 }
 attributes.each do |k, v|
  @attributes[k] = v
 end
end
\end{verbatim}

Иными словами, контроллер и рпедставления работают с экземплярами модели. С помощью вызова из контроллера методов модели с требуемыми аргументами мы можем построить нужные обращения к базе данных.\\

Сравним организацию ассоциативного массива с реляционной организацией таблицы. Создание таблицы осуществляется классовым методом create\_table():\\

\begin{verbatim}
def CheckInDesk.create_table(connection)
   begin
     connection.do("
      CREATE TABLE check_in_desks(
      id serial PRIMARY KEY,
      name varchar(16) UNIQUE NOT NULL,
      decription text
      ) WITH OIDS
   ")
   return true
   rescue DBI::ProgrammingErroor => e
   return false
   end
end
\end{verbatim}
Отнощение создаетс с внутренними идентификаторами OIDs, являющимися первичным ключом и недоступным извне.SQL-запрос реализуется через интерфейс DBI в секции обработки исключений. В случае генерации оного (таблица уже сущетвует, ошибка в SQL-синтаксисе, неверные параметры и т.д.) метод возвращает false.\\

Теперь, когда мы организовали связь между моделью и контроллером, следует задуматься о планируемой функциональности. В пользовательском интерфейсе должны быть предусмотрены следующие возможности:\\

1.Формирование списка всех существующих стоек\\
2.Добавление, редактирование и удаление объекта\\
3.Формирование списка всех стоек для рейса\\
4.Редкатирование списка стоек для рейса\\

Часть этих методов уже реализована в model.rb, в частности поиск записи по идентификатору find\_first(connection, id) и выборка всех кортежей find\_all(connection). Этого достаточно для независимой работы со стойками.\\

Поскольку в моделях пока нет средств обращения к БД см учетом этих связей, реализуем метод check-in-desk() в модели Flights. На его примере примере заодно покажем, как сообщаются контролери модель и производятся запросы к базе.\\

\begin{verbatim}
def check_in_desk(connection)
    res = []
    query = ["SELECT cd.*, cdf.id AS cdf_id
              FROM check_in_desks cd JOIN check_in_desk_flights cdf
              ON (cdf.check_in-desk_id = cd.id)
              WHERE cdf.flight_id = ?", self[:id]]
    connection.select_all(*query) do |r|
    f = CheckInDesk.new           
    r.column_names.each do |c|
    f[c.to_sym] = r[c]
end
res << f
end
return res
end
\end{verbatim}
\begin{itemize}
\item на входе у функции - идентификатор сессии;
\item res - массив экземпляров класса CheckInDesk;
\item query - массив, первым элементом которго служит строка SQL-запроса. Передаваемые в неё аргументы заменяются символом "?", после чего последовательно перечисляются в качестве следующих элементов res.\\
\item Метод Action::Base.connection.select\_all генерирует запрос к таблице в соответствии со своим аргументом - массивом query, "собранным" в SQL-строку. Заметим, что операция cid[key] для экземпляра CheckInDesk означает обращение к его хешу cid.attributes[key.to\_sym](Данный метод определен в суперклассе Model и справедлив для всех его дочерних классов).Т.к. ключи возвращаемого хеша - строковые константы, мы приводим их к символическому виду функцией to\_sym.\\ 
\end{itemize}

В классе Model также определены два метода table\_name() (для класса и для экземпляра), возвращающие название таблицы в БД, которой соответствует объект или класс.\\
\begin{verbatim}
def table_name()
self.class.table_name()
end
def Model.table_name()
self.to_s.gsub(/(\W)/, '_\1').downcase + 's'
end
\end{verbatim}


Перед промежуточными заглавными буквами имени класс-модели вставляется нижнее подчеркивание, после чего буквы приводятся к строчному виду идописывается окончание 's' (CheckInDesk становится check\_in\_desk). Этот принцип рекомендуется соблюдать при именовании таблиц, в противном случае требуется переопределить метод класса в подклассе.\\

Есди некоторое поле в таблице может принимать ограниченный набор текстовых значений, удобно завести в соответствующем классе хешевую константу, сопоставляющую каждому тектовому значению некоторый идентификатор. С помощью него можно ссылаться на это значение из таблицы.\\

По этому принципу в модели FlightStatus реализованы статусы:
\begin{verbatim}
STATUSES = {0 => 'отложен',
1 => 'взлетел'
2 => 'сел'
3 => 'отменен'}
...
status_id integer NOT NULL CONSTRAINT status\_id\_ck CHECK (status_id IN (0,1,2,3,4))
...
\end{verbatim}

Т.о. мы гарантируем, что значение статуса не может быть отлично от всех значений хеша.\\
Если дан экземпляра класса FlightStatus, тектовое представление его статуса можно просмотреть с помощью следующей конструкции:\\
\begin{verbatim}
FlightStatus::STATUSES[s[:status_id]]
\end{verbatim}
В модуле Helper будем реализовывать вспомогатльные методы.Например, если пользователь хочет посмотреть список стоек для некоторого рейса, модель выбирает записи из связуещей таблицы, где стойки, как мы видели, представлены только их идентификаторами, пользователя не интересующимися.\\
Метод, возвращающий имя стойки по ее id:
\begin{verbatim}
def convert_to_cid_name(id)
ans = CheckInDesk.find_first(@db, id)
return ans[:name]
end
\end{verbatim}
При работе с этой моделью мы будем использовать особй тип данных timestamp. Этот тип предполагает формат ввода YYYY.MM.DD HH:MI(ересь, а приятно...). Мы можем присвоить атрибуту экземпляра значение текущего времени при помощи функции Ruby Time.now
2.\emph{Контроллер.}Фома HTML представляет собой документ, созданный с использованием HTML элеменетов. Назначением данной формы является чбор информации от пользователей. После того как пользователь заполнит форму и запускает процесс её обработки, информация из неё попадает в программу, работающую на сервере(скрипту).\\

Инициализация механизма контроллеров в соответсвии с запросом пользователя реализована в aero.rb, которая и является нашим скриптом. Содержимое данного куска кода, помогает лучше понять как данные передаются в контроллер.\\

\begin{verbatim}
DEFAULT_CONTROLLER = 'Flights'
DEFAULT_ACTION = 'departure_list'
               def render()
               cgi = CGI.new('html4')
               begin
                unless cgi.params.include?('controller') or
                valid_controllers.include?(cgi.params['controller'][0])
                 cgi.params['controller'] = [DEFAULT_CONTROLLER]
                 cgi.params['action'] = [DEFAULT_ACTION]
               end
                c = eval(cgi.params['controller'][0] + 'Controller').new(cgi)
                cgi.out({
                 "type" => "text/html; charset=utf-8",
                 "language" => "ru"
                  }){ c.response() }
                      rescue Exception => e
                      cgi.out({
                       "type" => "text/html; charset=utf-8",
                       "language" => "ru"
                        }){ display_errors(e) }
               end
             end
\end{verbatim}
Алгоритм данного скрипта заключается в следующем:
\begin{itemize}
\item Создается экземпляр CGI для HTML 4.0; это ассоциативный массив, через который передаются параметры запроса в виде пар: key\_value\_set, где value\_set - массив из одного или более значений.
\item Метод hes\_key?(key) применяется к хешу и возвращает логическое значение true or false, в зависимости от того, содержит ли хеш ключ key.
\item Дописывая к названию контроллера слово Controller, получаем название класса-контроллера и создаем его экземпляр, добавив cgi в конструктор.
\item Метод cgi.out пишет http-заголовок и тело c.response() в вывод. response() добавляет к выходному html-документу header и footer из папки template/layouts.
\end{itemize}
Абстрагируясь от реализации конкретных методов, можно сказать, что в целом выполнение метода содержит следующие этапы:\\

1.Функция render() передает значения параметров в @cgi.params;\\
2.Постредством методов (экземпляров) класса Model или его подклассов производится обращение к соотвествующей таблице;\\
3.Представление обновляется с помощью функции render\_template().\\

Допустим, пользователь хочет посмотреть информацию о некотором рейсе,  идентификатор которого передается в контроллер. Ключи @cgi.params - строковые константы, а значения @cgi.params[key] - массивы (в нашем случае - одноэлементные).\\
\begin{verbatim}
def show()
@item = nil
if @cgi.params.has_key?('id) and @cgi.params['id'][0] != '''
@item = Flight.find_first(@db, @cgi.params['id'][0])
end
render_template(@item ? 'show' : 'not_found')
end
\end{verbatim}

1.Если методу был передан непустой id, при помощи метода класса Flight находим нужную запись и присваиваем возвращенный ассоциативный массив переменной @item (методу передается идентификатор сессии и рейса);\\
2.Генерируем представление в зависимости от того, был ли найден запрашиваемый рейс.\\

@item - экземпляр модели и переменная экземпляра контроллера, будем использовать в представлении. В базовом классе Controller реализован метод filter\_for\_params(), который выбирает из хеша переданых параметров только параметры с названием вида item[attribute\_key] и удаляет из них названия item[], оставляя только содержимое в [], и возвращает отфильтрованный хеш.\\

Рассмотрим метод добавления регистрационной стойки для рейса: В хеше параметров передаются идентификаторы рейса и стойки. Этими данными инициализируются значения переменной @item(экземпляр CheckInDeskFlight), после чего они добавляются в связующую таблицу при помощивызова item.save(connection).

\begin{verbatim}
def attach()
params = filter_for_params()
@item = CheckInDeskFlight.new
params.each do |k, v|
@item[k] = v[0] if k != 'id' and v != ''
end
@item.save(@db)
render_template(@action)
end
\end{verbatim}
\begin{itemize}
\item Производим выборку параметров хеш params;\\
\item Cоздаем экземпляр связующего класса CheckInDeskFlight и заполняем его хеш @attributes переданными значениями. При добавлении в таблицу идентификатор выдается самой СУБД и используется на практике только при извлечении информации (find\_first()), а потом в нашем методе он также игнорируетсяж\\
\item Запись сохраняется в БД, после чего контроллер обновляет представление.\\
\end{itemize}
3.\emph{Представление}
Файлы представлений (templates) с точки в Ruby, содержат единственный объект строку.Эта строка - прототип html-кода и потенциальный аргумент функции render\_template(), с помощью котой контроллер обновляет представление после произведенных операций.\\
\begin{verbatim}
def render_template(name, mode = :rb)
if mode == :rb
f = File.new("templates
/#{Convertors.class_name_to_controller_dir(@controller)}/#
{name}.rb")
html = eval(f.read)
f.close
return html
else
f = File.new("templates/#{@controller}/#{name}")
html = f.read
f.close
return html
end
end
def Convertors.class_name_to_controller_dir(class_name)
class_name.to_s.gsub(/(\W)/, '_\1').downcase
end
\end{verbatim}
1.Если функция вызывается с одним аргументом, продполагается, что этот аргумент - имя файла-представления без расширения. Полагается что расширением является .rb а путь до файла из каталога templates определяется функцией class\_name\_to\_controller\_dir() (эта функция аналогична уже рассмотренной функции table-name());\\
2.Из соответствуюзего файла считываются данные, после чего интерпретируются и подаются на исолнение. 
\vspace*{1см}Списки в представлениях формируются следующим способом: Мы можем передать в представление массив экземпляра нашего класса. Для каждого из них будем формировать отдельный html-блок и "пристыковывать" его к уже имеющемуся участку.\\
\begin{verbatim}
@items.map do |i|
count += 1
"
<tr class = 'list#{count%2}'>
<td>#{i[:name]}</td>
<td>#{i[:description]}</td>
<td>
#{action_links(@controller, i[:id], @user)}
</td>
15
</tr>
"
end.join("\n")
\end{verbatim}
При создании форм мы можем столкнуться с необходимостью ограничить пользователя в его выборе. Множество стоек тоже ограничено, но постоянно меняется: при "привязке" стойки к рейсу мы должны предложить пользователю только набор существующих на данный момент стоек. Для таких случаев в модуле Helper реализуем функции, формирующие набор нужных опций внутри тега <select>. Эти функции возвращают строку с нужным html-кодом. Принцип их работы схож с формированием списков и в подробном объяснении не нуждается.\\
\begin{verbatim}
def check_in_desk_select(name, selected, is_nil)
"<select name = '#{name}'>" +
CheckInDesk.find_all(@db).map do |c|
if c[:id].to_i == selected.to_i && selected!=0
"<option value = '#{c[:id]}' selected>#{c[:name]}</option>"
else
"<option value = '#{c[:id]}'>#{c[:name]}</option>"
end
end.join("\n") + (is_nil ?
(selected==0 ?
"<option value = '' selected> </option>":"<option value=''></option>")
: "") + "</select>"
end
\end{verbatim}
1.На входе у функции - имя параметра, значение которого мы определяем (name), id объекта-значения по умолчанию (selected) и параметр, определяющий, может ли name принять пустое значение (is\_nil);\\
2.Для каждого объекта из таблицы заносим его имя в список возможных значений; в cgi.params же будем передавать идентификатор;
3.Если selected == 0 и is\_nil == true, значением по умолчанию является пустая строка.
